<!DOCTYPE html>
<!-- Desarrollado por Sergio Tena -->
<!-- v3: Tabla Encriptada + Fix UT Diferente Estructura -->
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generador de Queries - Validación de Calidad de Datos v3</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        :root {
            --primary-blue: #003366;
            --secondary-blue: #0066CC;
            --light-blue: #E6F0FA;
            --accent-orange: #FF6600;
            --accent-red: #CC3300;
            --white: #FFFFFF;
            --gray-light: #F5F5F5;
            --gray-medium: #CCCCCC;
            --gray-dark: #666666;
            --text-dark: #333333;
            --success-green: #28a745;
            --error-red: #dc3545;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--gray-light);
            color: var(--text-dark);
            line-height: 1.6;
        }

        .header {
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--secondary-blue) 100%);
            color: var(--white);
            padding: 20px 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .header h1 {
            font-size: 1.8rem;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .header p {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 30px;
        }

        .mode-selector {
            background: var(--white);
            padding: 20px 30px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 25px;
            display: flex;
            align-items: center;
            gap: 30px;
            flex-wrap: wrap;
        }

        .mode-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .mode-selector label {
            font-weight: 600;
            color: var(--primary-blue);
            font-size: 0.95rem;
        }

        .mode-selector select {
            padding: 10px 15px;
            font-size: 0.95rem;
            border: 2px solid var(--secondary-blue);
            border-radius: 6px;
            background: var(--white);
            color: var(--primary-blue);
            cursor: pointer;
            min-width: 200px;
            transition: all 0.3s ease;
        }

        .mode-selector select:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(0, 102, 204, 0.2);
        }

        .section-card {
            background: var(--white);
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 25px;
            overflow: hidden;
        }

        .section-header {
            background: var(--primary-blue);
            color: var(--white);
            padding: 15px 25px;
            font-weight: 600;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section-header .badge {
            background: var(--accent-orange);
            padding: 3px 10px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .section-body {
            padding: 25px;
        }

        .form-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        .form-column {
            background: var(--gray-light);
            padding: 20px;
            border-radius: 6px;
            border-left: 4px solid var(--secondary-blue);
        }

        .form-column.origen {
            border-left-color: var(--secondary-blue);
        }

        .form-column.destino {
            border-left-color: var(--accent-orange);
        }

        .form-column h3 {
            color: var(--primary-blue);
            margin-bottom: 15px;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .form-column.destino h3 {
            color: var(--accent-red);
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: var(--gray-dark);
            font-size: 0.85rem;
        }

        .form-group label .required {
            color: var(--error-red);
            margin-left: 2px;
        }

        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--gray-medium);
            border-radius: 4px;
            font-size: 0.9rem;
            transition: border-color 0.3s ease;
        }

        .form-group input:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--secondary-blue);
            box-shadow: 0 0 0 3px rgba(0, 102, 204, 0.1);
        }

        .form-group input.error,
        .form-group textarea.error {
            border-color: var(--error-red);
            background-color: #fff5f5;
        }

        .form-group textarea {
            min-height: 80px;
            resize: vertical;
            font-family: 'Consolas', 'Monaco', monospace;
        }

        .form-group small {
            display: block;
            margin-top: 4px;
            color: var(--gray-dark);
            font-size: 0.75rem;
        }
        .form-group small code {
            background: #f0f4ff;
            color: #1a3a6b;
            border-radius: 3px;
            padding: 1px 4px;
            font-size: 0.72rem;
            font-family: 'Courier New', monospace;
        }
        .form-group small strong {
            color: #1a3a6b;
        }

        .form-group .error-message {
            color: var(--error-red);
            font-size: 0.8rem;
            margin-top: 4px;
            display: none;
        }

        .shared-fields {
            background: var(--light-blue);
            padding: 20px;
            border-radius: 6px;
            margin-bottom: 20px;
        }

        .shared-fields h3 {
            color: var(--primary-blue);
            margin-bottom: 15px;
            font-size: 1rem;
        }

        .record-fields {
            background: #FFF8E6;
            border: 2px dashed var(--accent-orange);
            padding: 20px;
            border-radius: 6px;
            margin-top: 20px;
            display: none;
        }

        .record-fields.visible {
            display: block;
        }

        .record-fields h3 {
            color: var(--accent-orange);
            margin-bottom: 15px;
            font-size: 1rem;
        }

        .different-fields {
            background: #E8F5E9;
            border: 2px dashed #4CAF50;
            padding: 20px;
            border-radius: 6px;
            margin-top: 20px;
            display: none;
        }

        .different-fields.visible {
            display: block;
        }

        .different-fields h3 {
            color: #2E7D32;
            margin-bottom: 15px;
            font-size: 1rem;
        }

        .bytes-check-group {
            background: #EDE7F6;
            border: 1px solid #CE93D8;
            border-radius: 6px;
            padding: 10px 14px;
        }

        .bytes-check-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-weight: 600;
            color: #4A148C;
            margin-bottom: 4px;
        }

        .bytes-check-label input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #7B1FA2;
            cursor: pointer;
        }

        /* Checkbox JOIN adicional */
        .join-check-group {
            background: #E8F4FD;
            border: 1px solid #90CAF9;
            border-radius: 6px;
            padding: 8px 14px;
            margin-bottom: 2px;
        }
        .join-check-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-weight: 600;
            color: #1a3a6b;
            font-size: 0.875rem;
        }
        .join-check-label input[type="checkbox"] {
            width: 15px;
            height: 15px;
            accent-color: #1565C0;
            cursor: pointer;
        }
        .join-textarea-group {
            margin-top: 4px;
            padding: 8px 14px 10px;
            background: #F0F7FF;
            border: 1px dashed #90CAF9;
            border-radius: 0 0 6px 6px;
        }

        .encrypted-fields {
            background: #F3E5F5;
            border: 2px dashed #7B1FA2;
            padding: 20px;
            border-radius: 6px;
            margin-top: 20px;
            display: none;
        }

        .encrypted-fields.visible {
            display: block;
        }

        .encrypted-fields h3 {
            color: #6A1B9A;
            margin-bottom: 15px;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .encrypted-info {
            background: #EDE7F6;
            border-left: 4px solid #7B1FA2;
            padding: 12px 15px;
            border-radius: 4px;
            margin-top: 12px;
            font-size: 0.85rem;
            color: #4A148C;
        }

        .mapping-grid {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 10px;
            align-items: start;
        }

        .mapping-arrow {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: #4CAF50;
            padding-top: 30px;
        }

        .mapping-example {
            background: #fff;
            border: 1px solid #C8E6C9;
            border-radius: 4px;
            padding: 10px;
            margin-top: 15px;
            font-size: 0.85rem;
        }

        .mapping-example code {
            background: #E8F5E9;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Consolas', monospace;
        }

        /* Layer Fields Styles */
        .layer-fields {
            background: linear-gradient(135deg, #FFF8E1 0%, #FFECB3 100%);
            border: 2px solid #FFC107;
            padding: 25px;
            border-radius: 8px;
            margin-top: 20px;
        }

        .layer-fields h3 {
            color: #F57C00;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .layer-flow-selector {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px;
            background: var(--white);
            border-radius: 6px;
        }

        .layer-flow-selector label {
            font-weight: 600;
            color: var(--primary-blue);
        }

        .layer-flow-selector select {
            padding: 10px 15px;
            font-size: 1rem;
            border: 2px solid var(--accent-orange);
            border-radius: 6px;
            background: var(--white);
            cursor: pointer;
            min-width: 280px;
        }

        .layer-flow-visual {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 15px;
            background: rgba(255,255,255,0.8);
            border-radius: 6px;
            margin-bottom: 20px;
        }

        .flow-step {
            background: var(--white);
            padding: 12px 25px;
            border-radius: 25px;
            font-weight: 600;
            font-size: 0.95rem;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .flow-step.origen-step {
            background: linear-gradient(135deg, #E3F2FD 0%, #BBDEFB 100%);
            border: 2px solid #2196F3;
        }

        .flow-step.destino-step {
            background: linear-gradient(135deg, #F3E5F5 0%, #E1BEE7 100%);
            border: 2px solid #9C27B0;
        }

        .flow-arrow {
            font-size: 2rem;
            color: var(--accent-orange);
            font-weight: bold;
        }

        .layer-config-section {
            background: var(--white);
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
        }

        .layer-tables-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
        }

        .layer-section {
            background: var(--white);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .layer-section-header {
            padding: 12px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
        }

        .origen-section .layer-section-header {
            background: linear-gradient(135deg, #E3F2FD 0%, #BBDEFB 100%);
            border-bottom: 3px solid #2196F3;
        }

        .destino-section .layer-section-header {
            background: linear-gradient(135deg, #F3E5F5 0%, #E1BEE7 100%);
            border-bottom: 3px solid #9C27B0;
        }

        .btn-add-table {
            background: #2196F3;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 600;
            transition: background 0.2s;
        }

        .btn-add-table:hover {
            background: #1976D2;
        }

        .origen-table-card, .destino-table-card {
            border-bottom: 1px solid #eee;
        }

        .origen-table-card:last-child {
            border-bottom: none;
        }

        .table-card-header {
            padding: 10px 15px;
            background: #f5f5f5;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--gray-dark);
        }

        .btn-remove-table {
            background: #dc3545;
            color: white;
            border: none;
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
        }

        .btn-remove-table:hover {
            background: #c82333;
        }

        .table-card-body {
            padding: 15px;
        }

        .table-card-body .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 10px;
        }

        .table-card-body .form-group {
            margin-bottom: 10px;
        }

        .table-card-body .form-group:last-child {
            margin-bottom: 0;
        }

        .table-card-body label {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--gray-dark);
            display: block;
            margin-bottom: 4px;
        }

        .table-card-body input {
            width: 100%;
            padding: 8px 10px;
            font-size: 0.85rem;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .table-card-body small {
            font-size: 0.7rem;
            color: #999;
        }

        .layer-rules-info {
            margin-top: 20px;
            background: var(--white);
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid var(--accent-orange);
        }

        .layer-rules-info ul {
            margin-top: 10px;
            padding-left: 20px;
        }

        .layer-rules-info li {
            margin-bottom: 5px;
            font-size: 0.85rem;
            color: var(--gray-dark);
        }

        @media (max-width: 1000px) {
            .layer-tables-container {
                grid-template-columns: 1fr;
            }
            .layer-flow-visual {
                flex-direction: column;
            }
            .flow-arrow {
                transform: rotate(90deg);
            }
        }

        /* Pipeline Analysis Styles */
        .pipeline-fields {
            background: linear-gradient(135deg, #E8EAF6 0%, #C5CAE9 100%);
            border: 2px solid #5C6BC0;
            padding: 25px;
            border-radius: 8px;
            margin-top: 20px;
        }

        .pipeline-fields h3 {
            color: #3949AB;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }

        .sp-container {
            margin-bottom: 20px;
        }

        .sp-card {
            background: var(--white);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .sp-card.main-sp {
            border: 2px solid #5C6BC0;
        }

        .sp-card.predecessor-sp {
            border: 2px solid #78909C;
            margin-bottom: 15px;
        }

        .sp-card-header {
            padding: 12px 15px;
            background: linear-gradient(135deg, #E8EAF6 0%, #C5CAE9 100%);
            border-bottom: 2px solid #5C6BC0;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sp-card.predecessor-sp .sp-card-header {
            background: linear-gradient(135deg, #ECEFF1 0%, #CFD8DC 100%);
            border-bottom: 2px solid #78909C;
        }

        .sp-card-body {
            padding: 15px;
        }

        .sp-card-body textarea {
            width: 100%;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.85rem;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            resize: vertical;
            background: #1e1e1e;
            color: #d4d4d4;
        }

        .sp-predecessors-section {
            margin-top: 20px;
        }

        .sp-predecessors-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px 15px;
            background: var(--white);
            border-radius: 6px;
        }

        .sp-predecessors-header span {
            font-weight: 600;
            color: var(--gray-dark);
        }

        .btn-add-sp {
            background: #78909C;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 600;
            transition: background 0.2s;
        }

        .btn-add-sp:hover {
            background: #546E7A;
        }

        .btn-remove-sp {
            background: #dc3545;
            color: white;
            border: none;
            padding: 4px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
        }

        .analyze-section {
            margin-top: 20px;
            text-align: center;
        }

        .btn-analyze {
            background: linear-gradient(135deg, #5C6BC0 0%, #3949AB 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1rem;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(92, 107, 192, 0.4);
        }

        .btn-analyze:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(92, 107, 192, 0.5);
        }

        #pipelineResults {
            margin-top: 25px;
            background: var(--white);
            border-radius: 8px;
            padding: 20px;
        }

        #pipelineResults h4 {
            color: #3949AB;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #C5CAE9;
        }

        .pipeline-diagram {
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 20px;
            margin-bottom: 20px;
            font-family: 'Consolas', monospace;
            font-size: 0.85rem;
            overflow-x: auto;
            white-space: pre;
        }

        .detected-tables-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .detected-section {
            background: #f8f9fa;
            border-radius: 6px;
            overflow: hidden;
        }

        .detected-section.raw-section {
            border: 2px solid #2196F3;
        }

        .detected-section.temp-section {
            border: 2px solid #9C27B0;
        }

        .detected-section.master-section {
            border: 2px solid #4CAF50;
        }

        .detected-header {
            padding: 10px 15px;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .raw-section .detected-header {
            background: linear-gradient(135deg, #E3F2FD 0%, #BBDEFB 100%);
            color: #1565C0;
        }

        .temp-section .detected-header {
            background: linear-gradient(135deg, #F3E5F5 0%, #E1BEE7 100%);
            color: #7B1FA2;
        }

        .master-section .detected-header {
            background: linear-gradient(135deg, #E8F5E9 0%, #C8E6C9 100%);
            color: #2E7D32;
        }

        .detected-list {
            padding: 10px 15px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Consolas', monospace;
            font-size: 0.8rem;
        }

        .detected-list .table-item {
            padding: 5px 8px;
            margin-bottom: 5px;
            background: var(--white);
            border-radius: 4px;
            border-left: 3px solid #ddd;
        }

        .raw-section .table-item { border-left-color: #2196F3; }
        .temp-section .table-item { border-left-color: #9C27B0; }
        .master-section .table-item { border-left-color: #4CAF50; }

        .btn-copy-small {
            width: 100%;
            padding: 8px;
            background: #f0f0f0;
            border: none;
            border-top: 1px solid #ddd;
            cursor: pointer;
            font-size: 0.8rem;
            transition: background 0.2s;
        }

        .btn-copy-small:hover {
            background: #e0e0e0;
        }

        .detected-pks {
            background: #FFF8E1;
            border: 2px solid #FFC107;
            border-radius: 6px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .detected-pks .detected-header {
            background: linear-gradient(135deg, #FFF8E1 0%, #FFECB3 100%);
            color: #F57C00;
        }

        .detected-pks .detected-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .detected-pks .pk-item {
            background: var(--white);
            padding: 5px 12px;
            border-radius: 15px;
            border: 1px solid #FFC107;
            font-size: 0.85rem;
        }

        .detected-filters {
            background: #E8F5E9;
            border: 2px solid #4CAF50;
            border-radius: 6px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .detected-filters .detected-header {
            background: linear-gradient(135deg, #E8F5E9 0%, #C8E6C9 100%);
            color: #2E7D32;
        }

        .detected-filters .detected-list {
            max-height: 150px;
        }

        .detected-filters .filter-item {
            background: var(--white);
            padding: 8px 12px;
            margin-bottom: 8px;
            border-radius: 4px;
            border-left: 3px solid #4CAF50;
            font-family: 'Consolas', monospace;
            font-size: 0.75rem;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .pipeline-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .btn-generate-inputs,
        .btn-generate-queries {
            padding: 12px 25px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
            transition: all 0.3s;
        }

        .btn-generate-inputs {
            background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%);
            color: white;
        }

        .btn-generate-queries {
            background: linear-gradient(135deg, #4CAF50 0%, #388E3C 100%);
            color: white;
        }

        .btn-generate-inputs:hover,
        .btn-generate-queries:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .pipeline-queries-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #C5CAE9;
        }

        .pipeline-queries-header h4 {
            margin: 0;
            border: none;
            padding: 0;
        }

        .btn-copy-all {
            background: linear-gradient(135deg, #5C6BC0 0%, #3949AB 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s;
        }

        .btn-copy-all:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(92, 107, 192, 0.4);
        }

        /* Estilos para queries del pipeline */
        #pipelineQueriesGrid .query-card {
            margin-bottom: 15px;
        }

        #pipelineQueriesGrid .query-header {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 12px 15px;
            background: linear-gradient(135deg, #5C6BC0 0%, #3949AB 100%);
        }

        #pipelineQueriesGrid .query-code {
            background: var(--white);
            color: #3949AB;
            padding: 4px 12px;
            border-radius: 4px;
            font-weight: 700;
            font-size: 0.85rem;
        }

        #pipelineQueriesGrid .query-title {
            flex: 1;
            color: var(--white);
            font-weight: 500;
        }

        #pipelineQueriesGrid .btn-copy {
            position: static;
            background: var(--white);
            color: #3949AB;
            border: none;
            padding: 6px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 600;
            transition: all 0.2s;
        }

        #pipelineQueriesGrid .btn-copy:hover {
            background: #E8EAF6;
            transform: scale(1.05);
        }

        #pipelineQueriesGrid .btn-copy.copied {
            background: var(--success-green);
            color: var(--white);
        }

        #pipelineQueriesGrid .query-content {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            margin: 0;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.8rem;
            overflow-x: auto;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }

        @media (max-width: 900px) {
            .detected-tables-grid {
                grid-template-columns: 1fr;
            }
            .pipeline-actions {
                flex-direction: column;
            }
        }

        .shared-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }

        .btn-generate {
            background: linear-gradient(135deg, var(--accent-orange) 0%, var(--accent-red) 100%);
            color: var(--white);
            border: none;
            padding: 15px 40px;
            font-size: 1.1rem;
            font-weight: 600;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 20px auto;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .btn-generate:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 102, 0, 0.4);
        }

        .btn-generate:disabled {
            background: var(--gray-medium);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .queries-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 20px;
        }

        .query-card {
            background: var(--gray-light);
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid var(--gray-medium);
        }

        .query-card.auxiliary {
            border: 2px solid var(--accent-orange);
        }

        .query-header {
            background: var(--secondary-blue);
            color: var(--white);
            padding: 12px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .query-card.auxiliary .query-header {
            background: var(--accent-orange);
        }

        .query-header h4 {
            font-size: 0.95rem;
            font-weight: 500;
        }

        .query-header .code-badge {
            background: var(--white);
            color: var(--secondary-blue);
            padding: 3px 10px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .query-card.auxiliary .query-header .code-badge {
            color: var(--accent-orange);
        }

        .query-body {
            position: relative;
        }

        .query-body pre {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            margin: 0;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.85rem;
            line-height: 1.5;
            max-height: 400px;
            overflow-y: auto;
        }

        .btn-copy {
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--accent-orange);
            color: var(--white);
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 500;
            transition: background 0.2s ease;
        }

        .btn-copy:hover {
            background: var(--accent-red);
        }

        .btn-copy.copied {
            background: var(--success-green);
        }

        .export-section {
            text-align: center;
            padding: 30px;
            background: var(--light-blue);
            border-radius: 8px;
            margin-top: 30px;
        }

        .btn-export {
            background: var(--primary-blue);
            color: var(--white);
            border: none;
            padding: 15px 30px;
            font-size: 1rem;
            font-weight: 600;
            border-radius: 6px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 10px;
            transition: background 0.2s ease;
        }

        .btn-export:hover {
            background: var(--secondary-blue);
        }

        .info-box {
            background: var(--light-blue);
            border-left: 4px solid var(--secondary-blue);
            padding: 15px 20px;
            margin-bottom: 20px;
            border-radius: 0 6px 6px 0;
        }

        .info-box p {
            margin: 0;
            font-size: 0.9rem;
            color: var(--primary-blue);
        }

        .validation-alert {
            background: #fff5f5;
            border: 1px solid var(--error-red);
            border-left: 4px solid var(--error-red);
            padding: 15px 20px;
            margin-bottom: 20px;
            border-radius: 0 6px 6px 0;
            display: none;
        }

        .validation-alert.visible {
            display: block;
        }

        .validation-alert p {
            margin: 0;
            color: var(--error-red);
            font-weight: 500;
        }

        .note-box {
            background: #FFF3CD;
            border: 1px solid #FFC107;
            border-radius: 6px;
            padding: 15px;
            margin-top: 15px;
        }

        .note-box strong {
            color: #856404;
        }

        .note-box code {
            background: #fff;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Consolas', monospace;
        }

        .step-indicator {
            display: inline-block;
            background: var(--accent-red);
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
            margin-left: 10px;
        }

        @media (max-width: 900px) {
            .form-grid {
                grid-template-columns: 1fr;
            }
            .shared-grid {
                grid-template-columns: 1fr;
            }
            .queries-grid {
                grid-template-columns: 1fr;
            }
            .mode-selector {
                flex-direction: column;
                align-items: flex-start;
            }
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <header class="header">
        <h1>🔍 Generador de Queries - Validación de Calidad de Datos</h1>
        <p>Genera queries SQL para validar datos en Google Cloud Platform (BigQuery)</p>
    </header>

    <div class="container">
        <!-- Mode Selector -->
        <div class="mode-selector">
            <div class="mode-group">
                <label for="modeSelect">Tipo de Validación:</label>
                <select id="modeSelect" onchange="changeMode()">
                    <option value="ut">Pruebas Unitarias (Data Engineer)</option>
                    <option value="qa">Validación QA (Analista QA)</option>
                    <option value="pipeline">📊 Análisis de Pipeline (SP)</option>
                </select>
            </div>
            <div class="mode-group" id="tableTypeGroup">
                <label for="tableTypeSelect">Tipo de tabla:</label>
                <select id="tableTypeSelect" onchange="changeTableType()">
                    <option value="simple">Tabla Simple</option>
                    <option value="record">Tabla con RECORD (ARRAY)</option>
                    <option value="different">Tabla con Diferente Estructura</option>
                </select>
            </div>
            <div class="mode-group" id="infoTypeGroup">
                <label for="infoTypeSelect">Tipo de información:</label>
                <select id="infoTypeSelect" onchange="changeInfoType()">
                    <option value="clear">En claro</option>
                    <option value="encrypted">🔐 Encriptado (BYTES)</option>
                </select>
            </div>
        </div>

        <!-- Info Box -->
        <div class="info-box" id="infoBox">
            <p id="infoText">
                <strong>Pruebas Unitarias:</strong> Validan integridad básica después de cada carga ETL. 
                Compara ORIGEN vs DESTINO para verificar conteo, unicidad y presencia de registros.
                <br><strong>📋 Nota:</strong> Los campos para validación se obtienen automáticamente de INFORMATION_SCHEMA.
            </p>
        </div>

        <!-- Validation Alert -->
        <div class="validation-alert" id="validationAlert">
            <p>⚠️ Por favor complete todos los campos requeridos marcados con *</p>
        </div>

        <!-- Input Section -->
        <div class="section-card">
            <div class="section-header">
                📝 Configuración de Tablas
                <span class="badge" id="modeBadge">Pruebas Unitarias</span>
                <span class="badge" id="tableTypeBadge" style="background: #28a745;">Tabla Simple</span>
                <span class="badge" id="infoTypeBadge" style="background: #7B1FA2; display: none;">🔐 Encriptado</span>
            </div>
            <div class="section-body">
                <!-- Shared Fields (hidden when mode is pipeline) -->
                <div class="shared-fields" id="sharedFieldsSection">
                    <h3>🔗 Campos Comunes</h3>
                    <div class="form-group">
                        <label for="primaryKeys">Primary Keys <span class="required">*</span></label>
                        <input type="text" id="primaryKeys" placeholder="ej: cliente_id, fecha">
                        <small>Separadas por coma. Deben existir en ambas tablas con el mismo nombre</small>
                        <div class="error-message">Este campo es requerido</div>
                    </div>
                    <div class="note-box">
                        <strong>💡 Nota:</strong> Los campos para comparar (R05-Nulos, R06/UT02-Duplicados, R07/UT03-Valores) 
                        se obtienen automáticamente de <code>INFORMATION_SCHEMA</code>. 
                        No es necesario ingresarlos manualmente.
                    </div>
                </div>

                <!-- Record Fields (only visible when table type is record) -->
                <div class="record-fields" id="recordFields">
                    <h3>📦 Configuración de RECORD/ARRAY</h3>
                    <div class="shared-grid">
                        <div class="form-group">
                            <label for="recordColumnOrigen">Columna RECORD Origen <span class="required">*</span></label>
                            <input type="text" id="recordColumnOrigen" placeholder="ej: DATOS_POLIZA">
                            <small>Nombre de la columna tipo RECORD/ARRAY en origen</small>
                        </div>
                        <div class="form-group">
                            <label for="recordColumnDestino">Columna RECORD Destino <span class="required">*</span></label>
                            <input type="text" id="recordColumnDestino" placeholder="ej: DATOS_POLIZA">
                            <small>Nombre de la columna tipo RECORD/ARRAY en destino</small>
                        </div>
                    </div>
                </div>

                <!-- Different Structure Fields (only visible when table type is different) -->
                <div class="different-fields" id="differentFields">
                    <h3>🔄 Mapeo de Campos (Diferente Estructura)</h3>
                    <p style="margin-bottom: 15px; color: #666; font-size: 0.9rem;">
                        Ingresa los campos en el <strong>mismo orden</strong>. El campo en posición 1 de origen se comparará con el campo en posición 1 de destino.
                    </p>
                    
                    <div class="mapping-grid">
                        <div class="form-group">
                            <label for="pkOrigen">Primary Keys ORIGEN <span class="required">*</span></label>
                            <input type="text" id="pkOrigen" placeholder="ej: cliente_id, fecha_venta">
                            <small>PKs del origen, separados por coma</small>
                        </div>
                        <div class="mapping-arrow">→</div>
                        <div class="form-group">
                            <label for="pkDestino">Primary Keys DESTINO <span class="required">*</span></label>
                            <input type="text" id="pkDestino" placeholder="ej: id_cliente, fec_venta">
                            <small>PKs del destino (mismo orden que origen)</small>
                        </div>
                    </div>

                    <div class="mapping-grid" style="margin-top: 15px;">
                        <div class="form-group">
                            <label for="camposOrigen">Campos a Comparar ORIGEN</label>
                            <textarea id="camposOrigen" placeholder="ej: nombre_cliente, monto_total, direccion" rows="3"></textarea>
                            <small>Campos del origen a comparar (opcional, si vacío usa INFORMATION_SCHEMA)</small>
                        </div>
                        <div class="mapping-arrow">→</div>
                        <div class="form-group">
                            <label for="camposDestino">Campos a Comparar DESTINO</label>
                            <textarea id="camposDestino" placeholder="ej: client_name, total_amount, address" rows="3"></textarea>
                            <small>Campos del destino (mismo orden que origen)</small>
                        </div>
                    </div>

                    <div class="mapping-example">
                        <strong>💡 Ejemplo de mapeo:</strong><br>
                        PKs: <code>cliente_id, fecha</code> → <code>id_cliente, fec_venta</code><br>
                        Campos: <code>nombre, monto</code> → <code>name, amount</code><br>
                        <span style="color: #666;">Resultado: cliente_id↔id_cliente, fecha↔fec_venta, nombre↔name, monto↔amount</span>
                    </div>
                </div>


                <!-- Encrypted Fields (visible when infoType is encrypted) -->
                <div class="encrypted-fields" id="encryptedFields">
                    <div class="encrypted-info">
                        <strong>🔐 Modo Encriptado (BYTES):</strong> El <strong>ORIGEN</strong> tiene los campos como <code>STRING</code> (texto plano) y el <strong>DESTINO</strong> como <code>BYTES</code> (encriptados).<br>
                        Las 3 reglas generan un <em>meta-query</em> de 2 pasos: <strong>Paso 1</strong> → ejecutar para obtener campos BYTES desde <code>INFORMATION_SCHEMA</code> y generar el SQL; <strong>Paso 2</strong> → ejecutar el SQL generado para comparar Origen (STRING) vs Destino (HEX/BYTES).<br>
                        <strong>Reglas:</strong> UT-E01/RE01 Top 5 Valores · UT-E02/RE02 Nulos/Vacíos · UT-E03/RE03 Top 5 Longitud<br>
                        <span id="encryptedTypeNote" style="color:#4A148C; font-weight:600; margin-top:6px; display:block;"></span>
                    </div>
                </div>

                <!-- Pipeline Analysis Fields (only visible when mode is pipeline) -->
                <div class="pipeline-fields" id="pipelineFields" style="display: none;">
                    <h3>📊 Análisis de Pipeline ETL (Stored Procedures)</h3>
                    <p style="margin-bottom: 15px; color: #666; font-size: 0.9rem;">
                        Pega el código SQL de tu SP y la herramienta analizará automáticamente las tablas origen, temporales, destino y las PKs de los JOINs.
                    </p>

                    <!-- SP Principal -->
                    <div class="sp-container" id="spMainContainer">
                        <div class="sp-card main-sp">
                            <div class="sp-card-header">
                                <span>📄 SP Principal (que carga la tabla Master)</span>
                            </div>
                            <div class="sp-card-body">
                                <textarea id="spMainCode" rows="12" placeholder="-- Pega aquí el código SQL del SP principal
-- Ejemplo:
BEGIN
CREATE OR REPLACE TABLE `proyecto.temp.tabla_temp`
AS
SELECT ...
FROM `proyecto.raw.tabla_origen` t1
INNER JOIN `proyecto.raw.otra_tabla` t2 ON t1.id = t2.id
...
INSERT INTO `proyecto.master.tabla_destino`
...
END"></textarea>
                            </div>
                            
                            <!-- PKs de MASTER/BUSINESS -->
                            <div class="sp-pk-config" style="margin-top: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #0066CC;">
                                <label for="masterPKs" style="font-weight: 600; color: #333;">
                                    🔑 PKs de la tabla MASTER/BUSINESS (separadas por coma):
                                </label>
                                <input type="text" id="masterPKs" 
                                    placeholder="Ej: NUMERO_POLIZA, ID_FUENTE" 
                                    style="width: 100%; padding: 10px; margin-top: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                                <small style="color: #666; display: block; margin-top: 5px;">
                                    💡 Si no se especifica, se detectará automáticamente del SQL (campos en JOINs con POLIZA, NUMERO, ID, etc.)
                                </small>
                            </div>
                        </div>
                    </div>

                    <!-- SPs Predecesores -->
                    <div class="sp-predecessors-section">
                        <div class="sp-predecessors-header">
                            <span>📁 SPs Predecesores (opcional)</span>
                            <button type="button" class="btn-add-sp" onclick="addPredecessorSP()">+ Agregar SP Predecesor</button>
                        </div>
                        <div id="spPredecessorsContainer">
                            <!-- Los SPs predecesores se agregan aquí dinámicamente -->
                        </div>
                    </div>

                    <!-- Botón Analizar -->
                    <div class="analyze-section">
                        <button type="button" class="btn-analyze" onclick="analyzePipeline()">
                            🔍 Analizar Pipeline
                        </button>
                    </div>

                    <!-- Resultados del Análisis -->
                    <div id="pipelineResults" style="display: none;">
                        <h4>📊 Resultados del Análisis</h4>
                        
                        <!-- Diagrama de Flujo -->
                        <div class="pipeline-diagram" id="pipelineDiagram">
                            <!-- Se genera dinámicamente -->
                        </div>

                        <!-- Tablas Detectadas -->
                        <div class="detected-tables-grid">
                            <div class="detected-section raw-section">
                                <div class="detected-header">📥 Tablas RAW Detectadas</div>
                                <div class="detected-list" id="rawTablesList"></div>
                                <button class="btn-copy-small" onclick="copyDetectedTables('raw')">📋 Copiar</button>
                            </div>
                            <div class="detected-section temp-section">
                                <div class="detected-header">⚙️ Tablas TEMP Detectadas</div>
                                <div class="detected-list" id="tempTablesList"></div>
                                <button class="btn-copy-small" onclick="copyDetectedTables('temp')">📋 Copiar</button>
                            </div>
                            <div class="detected-section master-section">
                                <div class="detected-header">📊 Tabla MASTER/BUSINESS Destino</div>
                                <div class="detected-list" id="masterTablesList"></div>
                                <button class="btn-copy-small" onclick="copyDetectedTables('master')">📋 Copiar</button>
                            </div>
                        </div>

                        <!-- PKs Detectadas -->
                        <div class="detected-pks">
                            <div class="detected-header">🔑 PKs Detectadas (de los JOINs)</div>
                            <div class="detected-list" id="detectedPKsList"></div>
                            <button class="btn-copy-small" onclick="copyDetectedPKs()">📋 Copiar PKs</button>
                        </div>

                        <!-- Filtros WHERE Detectados -->
                        <div class="detected-filters" id="detectedFiltersSection" style="display: none;">
                            <div class="detected-header">🔍 Filtros WHERE Detectados</div>
                            <div class="detected-list" id="detectedFiltersList"></div>
                        </div>

                        <!-- Acciones -->
                        <div class="pipeline-actions">
                            <button type="button" class="btn-generate-queries" onclick="generatePipelineQueries()">
                                🔧 Generar Queries de Validación Pipeline
                            </button>
                        </div>

                        <!-- Queries Generados -->
                        <div id="pipelineQueriesContainer" style="display: none;">
                            <div class="pipeline-queries-header">
                                <h4>📝 Queries de Validación Generados</h4>
                                <button type="button" class="btn-copy-all" onclick="copyAllPipelineQueries()">📋 Copiar Todos</button>
                            </div>
                            <div id="pipelineQueriesGrid" class="queries-grid"></div>
                        </div>
                    </div>
                </div>

                <!-- Standard Fields -->
                <div id="standardFields">

                <!-- Origen / Destino -->
                <div class="form-grid">
                    <!-- Origen -->
                    <div class="form-column origen">
                        <h3>📤 ORIGEN</h3>
                        <div class="form-group">
                            <label for="proyectoOrigen">Proyecto GCP <span class="required">*</span></label>
                            <input type="text" id="proyectoOrigen" placeholder="ej: mi-proyecto-origen">
                            <div class="error-message">Este campo es requerido</div>
                        </div>
                        <div class="form-group">
                            <label for="datasetOrigen">Dataset <span class="required">*</span></label>
                            <input type="text" id="datasetOrigen" placeholder="ej: dm_master_origen">
                            <div class="error-message">Este campo es requerido</div>
                        </div>
                        <div class="form-group">
                            <label for="tablaOrigen">Tabla <span class="required">*</span></label>
                            <input type="text" id="tablaOrigen" placeholder="ej: polizas">
                            <div class="error-message">Este campo es requerido</div>
                        </div>
                        <div class="form-group bytes-check-group" id="bytesOrigenGroup" style="display:none;">
                            <label class="bytes-check-label">
                                <input type="checkbox" id="origenHasBytes">
                                <span>Tiene campos BYTES</span>
                            </label>
                            <small id="bytesOrigenHint">Si está marcado: <strong>En claro</strong> → <code>AND data_type != 'BYTES'</code> (excluye BYTES) · <strong>Encriptado</strong> → <code>AND data_type = 'BYTES'</code> (solo BYTES)</small>
                        </div>
                        <div class="form-group">
                            <label for="filtroOrigen">Filtro WHERE (opcional)</label>
                            <textarea id="filtroOrigen" placeholder="ej: fecha >= '2024-01-01' AND estado = 'ACTIVO'"></textarea>
                            <small>⚠️ Solo las condiciones, <strong>sin</strong> la palabra <code>WHERE</code>. Ej: <code>campo = 'valor' AND otro &gt; 100</code></small>
                        </div>
                        <div class="form-group join-check-group">
                            <label class="join-check-label">
                                <input type="checkbox" id="hasJoinOrigen" onchange="toggleJoin('Origen')">
                                <span>🔗 ¿Tiene JOIN adicional?</span>
                            </label>
                        </div>
                        <div class="join-textarea-group" id="joinOrigenGroup" style="display:none;">
                            <label for="joinOrigen" style="font-size:0.82rem;color:#1a3a6b;font-weight:600;display:block;margin-bottom:4px;">JOIN adicional — tabla ORIGEN</label>
                            <textarea id="joinOrigen" placeholder="INNER JOIN `proyecto.dataset.lookup` lk ON o.campo_id = lk.id"></textarea>
                            <small>⚠️ Escribir la cláusula completa con <code>INNER/LEFT/RIGHT JOIN</code>.<br>
                            · La tabla <strong>ORIGEN</strong> tiene alias <code>o</code> en <u>todos</u> los queries → <code>ON o.campo = lk.campo</code><br>
                            · Múltiples JOINs: uno por línea</small>
                        </div>
                    </div>

                    <!-- Destino -->
                    <div class="form-column destino">
                        <h3>📥 DESTINO</h3>
                        <div class="form-group">
                            <label for="proyectoDestino">Proyecto GCP <span class="required">*</span></label>
                            <input type="text" id="proyectoDestino" placeholder="ej: mi-proyecto-destino">
                            <div class="error-message">Este campo es requerido</div>
                        </div>
                        <div class="form-group">
                            <label for="datasetDestino">Dataset <span class="required">*</span></label>
                            <input type="text" id="datasetDestino" placeholder="ej: dm_master_destino">
                            <div class="error-message">Este campo es requerido</div>
                        </div>
                        <div class="form-group">
                            <label for="tablaDestino">Tabla <span class="required">*</span></label>
                            <input type="text" id="tablaDestino" placeholder="ej: dim_polizas">
                            <div class="error-message">Este campo es requerido</div>
                        </div>
                        <div class="form-group bytes-check-group" id="bytesDestinoGroup" style="display:none;">
                            <label class="bytes-check-label">
                                <input type="checkbox" id="destinoHasBytes">
                                <span>Tiene campos BYTES</span>
                            </label>
                            <small id="bytesDestinoHint">Si está marcado: <strong>En claro</strong> → <code>AND data_type != 'BYTES'</code> (excluye BYTES) · <strong>Encriptado</strong> → <code>AND data_type = 'BYTES'</code> (solo BYTES)</small>
                        </div>
                        <div class="form-group">
                            <label for="filtroDestino">Filtro WHERE (opcional)</label>
                            <textarea id="filtroDestino" placeholder="ej: fecha >= '2024-01-01' AND estado = 'ACTIVO'"></textarea>
                            <small>⚠️ Solo las condiciones, <strong>sin</strong> la palabra <code>WHERE</code>. Ej: <code>campo = 'valor' AND otro &gt; 100</code></small>
                        </div>
                        <div class="form-group join-check-group">
                            <label class="join-check-label">
                                <input type="checkbox" id="hasJoinDestino" onchange="toggleJoin('Destino')">
                                <span>🔗 ¿Tiene JOIN adicional?</span>
                            </label>
                        </div>
                        <div class="join-textarea-group" id="joinDestinoGroup" style="display:none;">
                            <label for="joinDestino" style="font-size:0.82rem;color:#1a3a6b;font-weight:600;display:block;margin-bottom:4px;">JOIN adicional — tabla DESTINO</label>
                            <textarea id="joinDestino" placeholder="INNER JOIN `proyecto.dataset.lookup` lk ON d.campo_id = lk.id"></textarea>
                            <small>⚠️ Escribir la cláusula completa con <code>INNER/LEFT/RIGHT JOIN</code>.<br>
                            · La tabla <strong>DESTINO</strong> tiene alias <code>d</code> en <u>todos</u> los queries → <code>ON d.campo = lk.campo</code><br>
                            · Múltiples JOINs: uno por línea</small>
                        </div>
                    </div>
                </div>

                </div><!-- End standardFields -->

                <button class="btn-generate" id="generateQueriesBtn" onclick="generateQueries()">
                    ⚡ Generar Queries
                </button>
            </div>
        </div>

        <!-- Queries Output -->
        <div class="section-card" id="queriesSection">
            <div class="section-header">
                📋 Queries Generados
            </div>
            <div class="section-body">
                <div class="queries-grid" id="queriesGrid">
                    <!-- Queries will be inserted here -->
                </div>
            </div>
        </div>

        <!-- Export Section -->
        <div class="export-section">
            <button class="btn-export" onclick="exportToExcel()">
                📊 Exportar a Excel
            </button>
        </div>
    </div>

    <script>
        let currentMode = 'ut';
        let currentTableType = 'simple';
        let currentInfoType = 'clear';
        // ─── JOIN toggle ───────────────────────────────────────────────
        function toggleJoin(side) {
            const hasJoin = document.getElementById('hasJoin' + side).checked;
            const group   = document.getElementById('join' + side + 'Group');
            if (group) group.style.display = hasJoin ? 'block' : 'none';
            if (!hasJoin) {
                const ta = document.getElementById('join' + side);
                if (ta) ta.value = '';
            }
        }

        function resetJoinCheckboxes() {
            ['Origen', 'Destino'].forEach(side => {
                const cb = document.getElementById('hasJoin' + side);
                if (cb) cb.checked = false;
                toggleJoin(side);
            });
        }
        // ───────────────────────────────────────────────────────────────

        function changeMode() {
            currentMode = document.getElementById('modeSelect').value;
            const badge = document.getElementById('modeBadge');
            const infoText = document.getElementById('infoText');
            const tableTypeGroup = document.getElementById('tableTypeGroup');
            const infoTypeGroup = document.getElementById('infoTypeGroup');
            const pipelineFields = document.getElementById('pipelineFields');
            const standardFields = document.getElementById('standardFields');
            const sharedFieldsSection = document.getElementById('sharedFieldsSection');
            const recordFields = document.getElementById('recordFields');
            const differentFields = document.getElementById('differentFields');

            // Ocultar todas las secciones principales por defecto
            pipelineFields.style.display = 'none';
            standardFields.style.display = 'none';
            tableTypeGroup.style.display = 'none';
            if (infoTypeGroup) infoTypeGroup.style.display = 'none';
            sharedFieldsSection.style.display = 'none';
            const infoTypeBadge = document.getElementById('infoTypeBadge');
            if (infoTypeBadge) infoTypeBadge.style.display = 'none';
            
            // Ocultar campos especiales (usando classList para mantener compatibilidad)
            if (recordFields) recordFields.classList.remove('visible');
            if (differentFields) differentFields.classList.remove('visible');

            // Ocultar/mostrar secciones según el modo
            // Mostrar/ocultar botón Generar Queries (no aplica en pipeline)
            const generateQueriesBtn = document.getElementById('generateQueriesBtn');
            if (generateQueriesBtn) generateQueriesBtn.style.display = currentMode === 'pipeline' ? 'none' : 'block';

            if (currentMode === 'pipeline') {
                badge.textContent = 'Análisis Pipeline';
                badge.style.background = '#5C6BC0';
                infoText.innerHTML = `<strong>Análisis de Pipeline:</strong> Pega el código SQL de tus SPs y analiza automáticamente 
                    las tablas origen (RAW), temporales (TEMP) y destino (MASTER/BUSINESS), extrayendo las PKs de los JOINs.
                    <br><strong>📋 Resultado:</strong> Exporta a Excel con queries de validación RAW vs MASTER/BUSINESS.`;
                pipelineFields.style.display = 'block';
            } else {
                // Modos: ut (Pruebas Unitarias) o qa (Validación QA)
                tableTypeGroup.style.display = 'flex';
                if (infoTypeGroup) infoTypeGroup.style.display = 'flex';
                standardFields.style.display = 'block';
                sharedFieldsSection.style.display = 'block';
                
                // Aplicar el tipo de tabla seleccionado (esto mostrará record/different si aplica)
                changeTableType();
                changeInfoType();
                resetJoinCheckboxes();
                
                if (currentMode === 'ut') {
                    badge.textContent = 'Pruebas Unitarias';
                    badge.style.background = '#0066CC';
                    infoText.innerHTML = `<strong>Pruebas Unitarias:</strong> Validan integridad básica después de cada carga ETL. 
                        Compara ORIGEN vs DESTINO para verificar conteo, unicidad y presencia de registros.
                        <br><strong>📋 Nota:</strong> Los campos para validación se obtienen automáticamente de INFORMATION_SCHEMA.`;
                } else {
                    badge.textContent = 'Validación QA';
                    badge.style.background = '#0066CC';
                    infoText.innerHTML = `<strong>Validación QA:</strong> Validaciones completas entre ambientes. 
                        Incluye estructura, tipos de datos, conteo, nulos, duplicados y valores por PK.
                        <br><strong>📋 Nota:</strong> Los campos para validación se obtienen automáticamente de INFORMATION_SCHEMA.`;
                }
            }

            document.getElementById('queriesGrid').innerHTML = '';
        }

        // ============================================
        // FUNCIONES DE ANÁLISIS DE PIPELINE
        // ============================================
        
        let predecessorCount = 0;
        let pipelineAnalysis = {
            rawTables: [],
            tempTables: [],
            masterTables: [],
            detectedPKs: [],
            relationships: []
        };

        function addPredecessorSP() {
            predecessorCount++;
            const container = document.getElementById('spPredecessorsContainer');
            const newCard = document.createElement('div');
            newCard.className = 'sp-card predecessor-sp';
            newCard.dataset.index = predecessorCount;
            newCard.innerHTML = `
                <div class="sp-card-header">
                    <span>📁 SP Predecesor #${predecessorCount}</span>
                    <button type="button" class="btn-remove-sp" onclick="removePredecessorSP(this)">✕ Quitar</button>
                </div>
                <div class="sp-card-body">
                    <textarea class="predecessor-code" rows="10" placeholder="-- Pega aquí el código SQL del SP predecesor"></textarea>
                </div>
            `;
            container.appendChild(newCard);
        }

        function removePredecessorSP(button) {
            const card = button.closest('.sp-card');
            card.remove();
            // Renumerar
            const cards = document.querySelectorAll('.predecessor-sp');
            cards.forEach((c, i) => {
                c.querySelector('.sp-card-header span').textContent = `📁 SP Predecesor #${i + 1}`;
            });
            predecessorCount = cards.length;
        }

        function analyzePipeline() {
            // Recopilar todo el código SQL
            const mainCode = document.getElementById('spMainCode').value;
            const predecessorCodes = Array.from(document.querySelectorAll('.predecessor-code')).map(t => t.value);
            const allCode = [...predecessorCodes, mainCode].join('\n\n');

            if (!allCode.trim()) {
                alert('Por favor, pega al menos el SP principal.');
                return;
            }

            // Resetear análisis
            pipelineAnalysis = {
                rawTables: [],
                tempTables: [],
                masterTables: [],
                configTables: [],
                detectedPKs: [],
                whereFilters: [],
                relationships: [],
                tableRelations: {}, // Nuevo: relaciones específicas entre tablas
                tableFields: {}     // Nuevo: campos por tabla
            };

            // Parsear el SQL
            parseSQL(allCode);

            // Mostrar resultados
            displayPipelineResults();
        }

        function parseSQL(sql) {
            // Normalizar el SQL
            const normalizedSQL = sql.replace(/`/g, '`').replace(/'/g, "'");
            
            // Patrones para detectar tablas - SOLO el contenido entre backticks
            // Formato: `proyecto.dataset.tabla`
            const tablePattern = /`([a-zA-Z0-9_-]+\.[a-zA-Z0-9_]+\.[a-zA-Z0-9_]+)`/gi;
            
            // Detectar CREATE TABLE (temporales o destino) - solo contenido entre backticks
            const createPattern = /CREATE\s+(?:OR\s+REPLACE\s+)?TABLE\s+`([^`]+)`/gi;
            
            // Detectar INSERT INTO (destino) - solo contenido entre backticks
            const insertPattern = /INSERT\s+INTO\s+`([^`]+)`/gi;
            
            // Detectar MERGE INTO (destino) - solo contenido entre backticks
            const mergePattern = /MERGE\s+`([^`]+)`/gi;
            
            // Detectar FROM y JOIN (origen) - MEJORADO: solo captura hasta el backtick de cierre
            const fromJoinPattern = /(?:FROM|JOIN)\s+`([^`]+)`/gi;
            
            // Detectar PKs de los JOINs
            const joinOnPattern = /(?:INNER\s+)?(?:LEFT\s+)?(?:RIGHT\s+)?(?:FULL\s+)?(?:OUTER\s+)?JOIN[^ON]+ON\s+([^WHERE\n;]+)/gi;

            const allTables = new Set();
            const createdTables = new Set();
            const insertedTables = new Set();
            const mergedTables = new Set();

            // Función para limpiar y validar nombre de tabla
            function cleanTableName(tableName) {
                if (!tableName) return null;
                // Remover espacios y saltos de línea
                let cleaned = tableName.trim();
                // Verificar que tenga el formato proyecto.dataset.tabla
                const parts = cleaned.split('.');
                if (parts.length !== 3) return null;
                // Verificar que cada parte solo contenga caracteres válidos
                const validPattern = /^[a-zA-Z0-9_-]+$/;
                for (const part of parts) {
                    if (!validPattern.test(part.trim())) return null;
                }
                return parts.map(p => p.trim()).join('.');
            }

            // Extraer tablas creadas
            let match;
            while ((match = createPattern.exec(normalizedSQL)) !== null) {
                const cleanName = cleanTableName(match[1]);
                if (cleanName) createdTables.add(cleanName);
            }

            // Extraer tablas con INSERT
            while ((match = insertPattern.exec(normalizedSQL)) !== null) {
                const cleanName = cleanTableName(match[1]);
                if (cleanName) insertedTables.add(cleanName);
            }

            // Extraer tablas con MERGE
            while ((match = mergePattern.exec(normalizedSQL)) !== null) {
                const cleanName = cleanTableName(match[1]);
                if (cleanName) mergedTables.add(cleanName);
            }

            // Extraer todas las tablas de FROM y JOIN
            while ((match = fromJoinPattern.exec(normalizedSQL)) !== null) {
                const cleanName = cleanTableName(match[1]);
                if (cleanName) allTables.add(cleanName);
            }

            // Lista de palabras a excluir de las PKs (funciones SQL, campos de sistema, etc.)
            const excludedPKWords = new Set([
                // Funciones SQL
                'CAST', 'COALESCE', 'CONCAT', 'UPPER', 'LOWER', 'TRIM', 'LTRIM', 'RTRIM',
                'SAFE_CAST', 'IFNULL', 'NULLIF', 'IF', 'CASE', 'WHEN', 'THEN', 'ELSE', 'END',
                'DATE', 'DATETIME', 'TIMESTAMP', 'FORMAT_DATE', 'PARSE_DATE', 'EXTRACT',
                'SUM', 'COUNT', 'MAX', 'MIN', 'AVG', 'ROW_NUMBER', 'RANK', 'DENSE_RANK',
                'STRING_AGG', 'ARRAY_AGG', 'STRUCT', 'ARRAY', 'UNNEST', 'ORDINAL', 'OFFSET',
                'REPLACE', 'SUBSTRING', 'LENGTH', 'LPAD', 'RPAD', 'SPLIT', 'SAFE',
                'ROUND', 'FLOOR', 'CEIL', 'ABS', 'MOD', 'POWER', 'SQRT',
                'AND', 'OR', 'NOT', 'IN', 'EXISTS', 'BETWEEN', 'LIKE', 'IS', 'NULL',
                'TRUE', 'FALSE', 'AS', 'ON', 'WHERE', 'FROM', 'JOIN', 'LEFT', 'RIGHT', 'INNER', 'OUTER', 'FULL',
                'SELECT', 'INSERT', 'UPDATE', 'DELETE', 'CREATE', 'DROP', 'ALTER', 'TABLE',
                'INT64', 'STRING', 'FLOAT64', 'BOOL', 'BYTES', 'NUMERIC', 'DATE', 'TIME',
                // Campos de sistema/auditoría comunes
                'FECHA_CREACION', 'FECHA_MODIFICACION', 'FECHA_CARGA', 'FECHA_REGISTRO',
                'FECHA_OPERACION_REG_SISTEMA', 'FECHA_HORA_OPERACION', 'AUDITDATE', 'AUDITDATE_SYSTEM_DATE',
                'OPERATION_DATETIME', 'LAST_MODIFIED_DATE', 'CREATED_DATE',
                'STATUS_OPERATION', 'ESTADO_OPERACION', 'DESCRIPCION_EVENTO',
                // Campos técnicos
                'STATIC', 'DCOID', 'OPERATIONPK', 'PK', 'ID', 'HASH_DIFF', 'ROW_NUM', 'NUM_FILA', 'CORRELATIVO',
                'PRIORIDAD', 'PRIORIDAD_DOCUMENTO'
            ]);

            // Extraer PKs de los JOINs - más estricto
            // También almacenar las relaciones específicas entre tablas
            const pkSet = new Set();
            const tableRelations = {}; // {tabla: {otherTable: [campo1, campo2]}}
            const tableFields = {};    // {tabla: Set de campos}
            
            // Mapeo de aliases a tablas completas
            const aliasToTable = {};
            const aliasPattern = /(?:FROM|JOIN)\s+`([^`]+)`\s+(?:AS\s+)?(\w+)/gi;
            while ((match = aliasPattern.exec(normalizedSQL)) !== null) {
                const tableName = cleanTableName(match[1]);
                const alias = match[2].toUpperCase();
                if (tableName && alias) {
                    aliasToTable[alias] = tableName;
                }
            }
            // Guardar aliases detectados para filtrar PKs inválidas más adelante
            pipelineAnalysis.aliases = Object.keys(aliasToTable);
            
            while ((match = joinOnPattern.exec(normalizedSQL)) !== null) {
                const onClause = match[1];
                // Buscar patrones como: alias.campo = alias.campo (sin funciones)
                // Excluir líneas que contengan CAST, COALESCE, etc.
                if (!/CAST|COALESCE|SAFE_CAST|UPPER|LOWER|TRIM/i.test(onClause)) {
                    const pkMatches = onClause.matchAll(/(\w+)\.(\w+)\s*=\s*(\w+)\.(\w+)/g);
                    for (const pkMatch of pkMatches) {
                        const alias1 = pkMatch[1].toUpperCase();
                        const field1 = pkMatch[2].toUpperCase();
                        const alias2 = pkMatch[3].toUpperCase();
                        const field2 = pkMatch[4].toUpperCase();
                        
                        // Solo agregar si no está en la lista de exclusión
                        if (!excludedPKWords.has(field1) && field1.length > 2) {
                            pkSet.add(field1);
                            // Guardar la relación entre tablas
                            const table1 = aliasToTable[alias1];
                            const table2 = aliasToTable[alias2];
                            if (table1) {
                                if (!tableFields[table1]) tableFields[table1] = new Set();
                                tableFields[table1].add(field1);
                            }
                            if (table2) {
                                if (!tableFields[table2]) tableFields[table2] = new Set();
                                tableFields[table2].add(field2);
                            }
                            // Guardar relación bidireccional
                            if (table1 && table2) {
                                if (!tableRelations[table1]) tableRelations[table1] = {};
                                if (!tableRelations[table1][table2]) tableRelations[table1][table2] = [];
                                if (!tableRelations[table1][table2].includes(field1)) {
                                    tableRelations[table1][table2].push(field1);
                                }
                                if (!tableRelations[table2]) tableRelations[table2] = {};
                                if (!tableRelations[table2][table1]) tableRelations[table2][table1] = [];
                                if (!tableRelations[table2][table1].includes(field2)) {
                                    tableRelations[table2][table1].push(field2);
                                }
                            }
                        }
                        if (!excludedPKWords.has(field2) && field2.length > 2) {
                            pkSet.add(field2);
                        }
                    }
                }
            }
            
            pipelineAnalysis.tableRelations = tableRelations;
            pipelineAnalysis.tableFields = tableFields;

            // También buscar campos en PARTITION BY que podrían ser PKs
            const partitionPattern = /PARTITION\s+BY\s+([^)]+)/gi;
            while ((match = partitionPattern.exec(normalizedSQL)) !== null) {
                const fields = match[1].split(',').map(f => {
                    const fieldMatch = f.trim().match(/(?:\w+\.)?(\w+)/);
                    return fieldMatch ? fieldMatch[1].toUpperCase() : null;
                }).filter(f => f && !excludedPKWords.has(f) && f.length > 2);
                fields.forEach(f => pkSet.add(f));
            }

            // Extraer filtros WHERE asociados a cada tabla
            const tableFilters = {};
            
            // Buscar patrones: FROM `tabla` ... WHERE condicion
            const fromWherePattern = /FROM\s+`([^`]+)`[^W]*?WHERE\s+([^;]+?)(?=\s+(?:GROUP|ORDER|QUALIFY|UNION|LIMIT|;|\)|\n\n|$))/gi;
            while ((match = fromWherePattern.exec(normalizedSQL)) !== null) {
                const tableName = cleanTableName(match[1]);
                const whereClause = match[2].trim()
                    .replace(/\s+/g, ' ')  // Normalizar espacios
                    .replace(/AND\s+NOT\s+EXISTS.*/gi, '')  // Quitar NOT EXISTS
                    .replace(/AND\s+EXISTS.*/gi, '')  // Quitar EXISTS
                    .split(/\s+QUALIFY\s+/i)[0]  // Quitar QUALIFY
                    .trim();
                
                if (tableName && whereClause && whereClause.length > 3 && whereClause.length < 300) {
                    if (!tableFilters[tableName]) {
                        tableFilters[tableName] = [];
                    }
                    // Evitar duplicados
                    if (!tableFilters[tableName].includes(whereClause)) {
                        tableFilters[tableName].push(whereClause);
                    }
                }
            }
            
            pipelineAnalysis.tableFilters = tableFilters;
            pipelineAnalysis.whereFilters = Object.entries(tableFilters).map(([table, filters]) => 
                `${table.split('.').pop()}: ${filters[0].substring(0, 100)}${filters[0].length > 100 ? '...' : ''}`
            );

            // Clasificar las tablas
            allTables.forEach(table => {
                const tableLower = table.toLowerCase();
                const parts = table.split('.');
                const dataset = parts.length >= 2 ? parts[parts.length - 2].toLowerCase() : '';
                const tableName = parts.length >= 1 ? parts[parts.length - 1].toLowerCase() : '';

                // Determinar el tipo de tabla
                if (dataset.includes('raw') || dataset.startsWith('raw_')) {
                    pipelineAnalysis.rawTables.push(table);
                } else if (dataset.includes('temp') || tableName.startsWith('tmp_') || tableName.startsWith('temp_')) {
                    if (!createdTables.has(table)) {
                        pipelineAnalysis.tempTables.push(table);
                    }
                } else if (dataset.includes('config') || dataset.includes('cnf')) {
                    pipelineAnalysis.configTables.push(table);
                } else if (!createdTables.has(table) && !insertedTables.has(table) && !mergedTables.has(table)) {
                    // Si no es creada ni insertada, es origen
                    pipelineAnalysis.rawTables.push(table);
                }
            });

            // Las tablas creadas que también tienen INSERT o están en temp son temporales
            createdTables.forEach(table => {
                const tableLower = table.toLowerCase();
                const parts = table.split('.');
                const dataset = parts.length >= 2 ? parts[parts.length - 2].toLowerCase() : '';
                
                if (dataset.includes('temp') || dataset.includes('tmp')) {
                    pipelineAnalysis.tempTables.push(table);
                } else if (dataset.includes('master') || dataset.includes('business')) {
                    pipelineAnalysis.masterTables.push(table);
                } else {
                    pipelineAnalysis.tempTables.push(table);
                }
            });

            // Las tablas con INSERT o MERGE que están en master/business son destino
            insertedTables.forEach(table => {
                const tableLower = table.toLowerCase();
                const parts = table.split('.');
                const dataset = parts.length >= 2 ? parts[parts.length - 2].toLowerCase() : '';
                
                if (dataset.includes('master') || dataset.includes('business')) {
                    if (!pipelineAnalysis.masterTables.includes(table)) {
                        pipelineAnalysis.masterTables.push(table);
                    }
                }
            });

            mergedTables.forEach(table => {
                const tableLower = table.toLowerCase();
                const parts = table.split('.');
                const dataset = parts.length >= 2 ? parts[parts.length - 2].toLowerCase() : '';
                
                if (dataset.includes('master') || dataset.includes('business')) {
                    if (!pipelineAnalysis.masterTables.includes(table)) {
                        pipelineAnalysis.masterTables.push(table);
                    }
                }
            });

            // Eliminar duplicados y ordenar
            pipelineAnalysis.rawTables = [...new Set(pipelineAnalysis.rawTables)].sort();
            pipelineAnalysis.tempTables = [...new Set(pipelineAnalysis.tempTables)].sort();
            pipelineAnalysis.masterTables = [...new Set(pipelineAnalysis.masterTables)].sort();
            
            // Filtrar PKs - priorizar campos que parecen ser llaves
            const pkPriority = ['NUMERO_POLIZA', 'ID_POLIZA', 'ID_PRODUCTO', 'ID_FUENTE', 'NUM_POLIZA', 
                                'COD_POLIZA', 'ID_CLIENTE', 'NUMERO_DOCUMENTO', 'ID_PERSONA'];
            
            let filteredPKs = [...pkSet].filter(pk => {
                // Excluir si es muy corto
                if (pk.length <= 2) return false;
                // Excluir si parece ser un campo de fecha/hora
                if (/^FECHA|^FEC_|_FECHA$|_DATE$|DATETIME|TIMESTAMP|_HORA|AUDITDATE/i.test(pk)) return false;
                // Excluir si parece ser un campo de estado/operación
                if (/^ESTADO|OPERATION|STATUS|_SISTEMA$/i.test(pk)) return false;
                // Excluir si es una función o palabra reservada
                if (excludedPKWords.has(pk)) return false;
                return true;
            });

            // Ordenar poniendo primero las PKs conocidas
            filteredPKs.sort((a, b) => {
                const aIdx = pkPriority.indexOf(a);
                const bIdx = pkPriority.indexOf(b);
                if (aIdx !== -1 && bIdx !== -1) return aIdx - bIdx;
                if (aIdx !== -1) return -1;
                if (bIdx !== -1) return 1;
                return a.localeCompare(b);
            });

            pipelineAnalysis.detectedPKs = filteredPKs;
        }

        function displayPipelineResults() {
            document.getElementById('pipelineResults').style.display = 'block';

            // Generar diagrama de flujo
            const diagramHTML = generatePipelineDiagram();
            document.getElementById('pipelineDiagram').innerHTML = diagramHTML;

            // Mostrar tablas RAW
            const rawList = document.getElementById('rawTablesList');
            rawList.innerHTML = pipelineAnalysis.rawTables.length > 0 
                ? pipelineAnalysis.rawTables.map(t => `<div class="table-item">${t}</div>`).join('')
                : '<div class="table-item" style="color: #999;">No se detectaron tablas RAW</div>';

            // Mostrar tablas TEMP
            const tempList = document.getElementById('tempTablesList');
            tempList.innerHTML = pipelineAnalysis.tempTables.length > 0
                ? pipelineAnalysis.tempTables.map(t => `<div class="table-item">${t}</div>`).join('')
                : '<div class="table-item" style="color: #999;">No se detectaron tablas TEMP</div>';

            // Mostrar tablas MASTER
            const masterList = document.getElementById('masterTablesList');
            masterList.innerHTML = pipelineAnalysis.masterTables.length > 0
                ? pipelineAnalysis.masterTables.map(t => `<div class="table-item">${t}</div>`).join('')
                : '<div class="table-item" style="color: #999;">No se detectaron tablas MASTER/BUSINESS</div>';

            // Mostrar PKs detectadas
            const pksList = document.getElementById('detectedPKsList');
            pksList.innerHTML = pipelineAnalysis.detectedPKs.length > 0
                ? pipelineAnalysis.detectedPKs.map(pk => `<span class="pk-item">${pk}</span>`).join('')
                : '<span class="pk-item" style="color: #999;">No se detectaron PKs</span>';

            // Mostrar filtros WHERE detectados
            const filtersSection = document.getElementById('detectedFiltersSection');
            const filtersList = document.getElementById('detectedFiltersList');
            if (pipelineAnalysis.whereFilters && pipelineAnalysis.whereFilters.length > 0) {
                filtersSection.style.display = 'block';
                filtersList.innerHTML = pipelineAnalysis.whereFilters.slice(0, 5).map(f => 
                    `<div class="filter-item">${escapeHtml(f.substring(0, 200))}${f.length > 200 ? '...' : ''}</div>`
                ).join('');
            } else {
                filtersSection.style.display = 'none';
            }
        }

        function generatePipelineDiagram() {
            const rawCount = pipelineAnalysis.rawTables.length;
            const tempCount = pipelineAnalysis.tempTables.length;
            const masterCount = pipelineAnalysis.masterTables.length;

            let diagram = `
┌─────────────────────────────────────────────────────────────────────────────┐
│                           📊 FLUJO DEL PIPELINE                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   📥 RAW (${rawCount} tablas)     ⚙️ TEMP (${tempCount} tablas)     📊 MASTER/BUS (${masterCount})   │
│   ┌─────────────┐       ┌─────────────┐       ┌─────────────┐              │
│   │`;
            
            // Mostrar algunas tablas de ejemplo
            const rawSample = pipelineAnalysis.rawTables.slice(0, 3).map(t => t.split('.').pop().substring(0, 12));
            const tempSample = pipelineAnalysis.tempTables.slice(0, 3).map(t => t.split('.').pop().substring(0, 12));
            const masterSample = pipelineAnalysis.masterTables.slice(0, 1).map(t => t.split('.').pop().substring(0, 12));

            diagram += ` ${(rawSample[0] || '...').padEnd(11)} │ ──┐   │ ${(tempSample[0] || '...').padEnd(11)} │ ──┐   │ ${(masterSample[0] || '...').padEnd(11)} │              │
│   │ ${(rawSample[1] || '').padEnd(11)} │ ──┼─► │ ${(tempSample[1] || '').padEnd(11)} │ ──┼─► │             │              │
│   │ ${(rawSample[2] || '').padEnd(11)} │ ──┘   │ ${(tempSample[2] || '').padEnd(11)} │ ──┘   │             │              │
│   │ ${rawCount > 3 ? '...' : ''}           │       │ ${tempCount > 3 ? '...' : ''}           │       └─────────────┘              │
│   └─────────────┘       └─────────────┘                                     │
│                                                                             │
│   PKs detectadas: ${pipelineAnalysis.detectedPKs.slice(0, 5).join(', ')}${pipelineAnalysis.detectedPKs.length > 5 ? '...' : ''}
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘`;

            return diagram;
        }

        function copyDetectedTables(type) {
            let tables = [];
            if (type === 'raw') tables = pipelineAnalysis.rawTables;
            else if (type === 'temp') tables = pipelineAnalysis.tempTables;
            else if (type === 'master') tables = pipelineAnalysis.masterTables;

            const text = tables.join('\n');
            navigator.clipboard.writeText(text).then(() => {
                alert(`${tables.length} tablas copiadas al portapapeles`);
            });
        }

        function copyDetectedPKs() {
            const text = pipelineAnalysis.detectedPKs.join(', ');
            navigator.clipboard.writeText(text).then(() => {
                alert(`${pipelineAnalysis.detectedPKs.length} PKs copiadas al portapapeles`);
            });
        }

        // Función para extraer el bloque SELECT principal del SP
        function extractMainSelectBlock(sql, masterTable) {
            try {
                // Buscar el INSERT INTO o CREATE TABLE que alimenta a MASTER
                const masterTableName = masterTable.replace(/`/g, '');
                const patterns = [
                    // INSERT INTO `tabla` ... SELECT ... FROM
                    new RegExp(`INSERT\\s+INTO\\s+\`${masterTableName.replace(/\./g, '\\.')}\`[^;]*?\\bSELECT\\b[\\s\\S]*?(FROM[\\s\\S]*?)(?=;|$)`, 'i'),
                    // CREATE TABLE `tabla` AS SELECT ... FROM
                    new RegExp(`CREATE[^;]*TABLE\\s+\`${masterTableName.replace(/\./g, '\\.')}\`[^;]*?AS\\s+SELECT[\\s\\S]*?(FROM[\\s\\S]*?)(?=;|$)`, 'i'),
                    // Buscar el SELECT más grande que tiene la tabla MASTER mencionada antes
                    /INSERT\s+INTO[^;]*?\bSELECT\b[\s\S]*?(FROM[\s\S]*?)(?=;|$)/i
                ];
                
                for (const pattern of patterns) {
                    const match = sql.match(pattern);
                    if (match && match[1]) {
                        let fromBlock = match[1].trim();
                        
                        // Si hay subqueries (FROM ( o JOIN ( o (SELECT), es muy complejo - retornar null
                        // para que se generen queries simples sin replicar la lógica del SP
                        const hasSubquery = /\bFROM\s*\(|\bJOIN\s*\(|\(\s*SELECT\b/i.test(fromBlock);
                        if (hasSubquery) {
                            // SP tiene subqueries complejas, no podemos extraer el bloque de forma segura
                            return null;
                        }
                        
                        // Solo procesar si NO hay subqueries
                        // Limpiar el bloque FROM/JOIN/WHERE
                        fromBlock = fromBlock
                            .replace(/\s+/g, ' ')  // Normalizar espacios
                            .replace(/QUALIFY\s+.*/i, '')  // Quitar QUALIFY
                            .replace(/GROUP\s+BY\s+[\d,\s]+$/i, '')  // Quitar GROUP BY simple al final
                            .replace(/\)\s*;?\s*$/g, '')  // Quitar paréntesis y ; al final
                            .trim();
                        
                        // Verificar que el bloque tiene sentido (al menos un FROM con tabla)
                        if (fromBlock.match(/^FROM\s+`[^`]+`/i)) {
                            return fromBlock;
                        }
                    }
                }
                
                // Si no encontramos el SELECT principal, intentar extraer el FROM más complejo
                const fromMatch = sql.match(/FROM\s+`[^`]+`(?:\s+\w+)?(?:\s+(?:INNER|LEFT|RIGHT|FULL|CROSS)?\s*JOIN\s+`[^`]+`(?:\s+\w+)?\s+ON\s+[^;]+)+(?:\s+WHERE\s+[^;]+)?/i);
                if (fromMatch) {
                    let cleanBlock = fromMatch[0].trim();
                    const hasSubquery = /\bFROM\s*\(|\bJOIN\s*\(|\(\s*SELECT\b/i.test(cleanBlock);
                    if (!hasSubquery) {
                        // Limpiar WHERE de aliases problemáticos
                        const whereMatch2 = cleanBlock.match(/\bWHERE\s+(.+)$/i);
                        if (whereMatch2) {
                            let whereClause2 = whereMatch2[1];
                            whereClause2 = whereClause2.replace(/\b[A-Z]{2,5}\.[A-Z_]+\s*=\s*[^ANDOR]+(\s+(AND|OR)\s+)?/gi, '');
                            whereClause2 = whereClause2.replace(/\b[A-Z]{2,5}\b(\s+(AND|OR)\b)?/gi, '');
                            whereClause2 = whereClause2.replace(/\bWHERE\b/gi, '');
                            whereClause2 = whereClause2.replace(/\s+(AND|OR)\s+$/i, '').trim();
                            if (whereClause2 && !/^(AND|OR|\s)+$/i.test(whereClause2)) {
                                cleanBlock = cleanBlock.replace(/\bWHERE\s+.*$/i, ` WHERE ${whereClause2}`);
                            } else {
                                cleanBlock = cleanBlock.replace(/\bWHERE\s+.*$/i, '');
                            }
                        }
                    } else {
                        cleanBlock = cleanBlock.replace(/\s+/g, ' ').trim();
                    }
                    return sanitizeFromBlock(cleanBlock);
                }
                
                return null;
            } catch (e) {
                console.error('Error extrayendo bloque SELECT:', e);
                return null;
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Variable para almacenar los queries generados
        let generatedPipelineQueries = [];

        function copyPipelineQuery(index, btn) {
            const query = generatedPipelineQueries[index].query;
            navigator.clipboard.writeText(query).then(() => {
                btn.textContent = '✓ Copiado';
                btn.classList.add('copied');
                setTimeout(() => {
                    btn.textContent = '📋 Copiar';
                    btn.classList.remove('copied');
                }, 2000);
            });
        }

        function copyAllPipelineQueries() {
            if (generatedPipelineQueries.length === 0) {
                alert('No hay queries para copiar.');
                return;
            }
            
            const allQueries = generatedPipelineQueries.map(q => 
                `-- ═══════════════════════════════════════════════════════════════\n-- ${q.code}: ${q.title}\n-- ═══════════════════════════════════════════════════════════════\n\n${q.query}`
            ).join('\n\n\n');
            
            navigator.clipboard.writeText(allQueries).then(() => {
                alert(`✅ ${generatedPipelineQueries.length} queries copiados al portapapeles`);
            });
        }

        function generatePipelineQueries() {
            if (pipelineAnalysis.rawTables.length === 0 || pipelineAnalysis.masterTables.length === 0) {
                alert('No se detectaron suficientes tablas. Asegúrate de que el SP tenga tablas RAW y MASTER/BUSINESS.');
                return;
            }

            const container = document.getElementById('pipelineQueriesContainer');
            container.style.display = 'block';
            const grid = document.getElementById('pipelineQueriesGrid');
            grid.innerHTML = '';

            const masterTable = pipelineAnalysis.masterTables[0];
            const masterTableName = masterTable.split('.').pop();

            const queries = [];
            
            // ═══════════════════════════════════════════════════════════════
            // Obtener el código SQL completo
            // ═══════════════════════════════════════════════════════════════
            const mainCode = document.getElementById('spMainCode').value;
            const predecessorCodes = Array.from(document.querySelectorAll('.predecessor-code')).map(t => t.value);
            const allCode = [...predecessorCodes, mainCode].join('\n\n');
            
            // ═══════════════════════════════════════════════════════════════
            // ANALIZAR CADA BLOQUE DEL PIPELINE
            // ═══════════════════════════════════════════════════════════════
            
            function extractPipelineBlocksLocal(sql) {
                const blocks = [];
                
                // Normalizar SQL
                let cleanSQL = sql
                    .replace(/--[^\n]*/g, '')
                    .replace(/\/\*[\s\S]*?\*\//g, '');
                
                const sqlParts = cleanSQL.split(/(?=INSERT\s+INTO\s+[`\w]|CREATE\s+(?:OR\s+REPLACE\s+)?(?:TEMP\s+|TEMPORARY\s+)?TABLE\s+[`\w]|CREATE\s+TABLE\s+IF\s+NOT\s+EXISTS\s+[`\w])/i);
                
                sqlParts.forEach(part => {
                    processBlockLocal(part, blocks);
                });
                
                return blocks;
            }
            
            function processBlockLocal(part, blocks) {
                if (!part.trim()) return;
                
                const normalizedPart = part.replace(/\s+/g, ' ').trim();
                
                let insertMatch = normalizedPart.match(/INSERT\s+INTO\s+`([^`]+)`/i);
                if (!insertMatch) {
                    insertMatch = normalizedPart.match(/INSERT\s+INTO\s+([\w\-\.]+)/i);
                }
                
                if (insertMatch) {
                    const destTable = insertMatch[1];
                    const selectMatch = normalizedPart.match(/SELECT[\s\S]*/i);
                    if (selectMatch) {
                        let cleanSelect = selectMatch[0].replace(/;/g, '').trim();
                        addBlockLocal(blocks, 'INSERT', destTable, cleanSelect);
                    }
                    return;
                }
                
                let createMatch = normalizedPart.match(/CREATE\s+(?:OR\s+REPLACE\s+)?(?:TEMP\s+|TEMPORARY\s+)?TABLE\s+(?:IF\s+NOT\s+EXISTS\s+)?`([^`]+)`(?:\s+AS)?\s+(SELECT[\s\S]*)/i);
                
                if (!createMatch) {
                    createMatch = normalizedPart.match(/CREATE\s+(?:OR\s+REPLACE\s+)?(?:TEMP\s+|TEMPORARY\s+)?TABLE\s+(?:IF\s+NOT\s+EXISTS\s+)?([\w\-\.]+)(?:\s+AS)?\s+(SELECT[\s\S]*)/i);
                }
                
                if (createMatch) {
                    const destTable = createMatch[1];
                    let cleanSelect = createMatch[2].replace(/;/g, '').trim();
                    addBlockLocal(blocks, 'CREATE', destTable, cleanSelect);
                    return;
                }
                
                let tableOnlyMatch = normalizedPart.match(/CREATE\s+(?:OR\s+REPLACE\s+)?(?:TEMP\s+|TEMPORARY\s+)?TABLE\s+(?:IF\s+NOT\s+EXISTS\s+)?`([^`]+)`/i);
                if (!tableOnlyMatch) {
                    tableOnlyMatch = normalizedPart.match(/CREATE\s+(?:OR\s+REPLACE\s+)?(?:TEMP\s+|TEMPORARY\s+)?TABLE\s+(?:IF\s+NOT\s+EXISTS\s+)?([\w\-\.]+)/i);
                }
                
                if (tableOnlyMatch) {
                    const destTable = tableOnlyMatch[1];
                    const selectMatch = normalizedPart.match(/SELECT[\s\S]*/i);
                    if (selectMatch) {
                        let cleanSelect = selectMatch[0].replace(/;/g, '').trim();
                        addBlockLocal(blocks, 'CREATE', destTable, cleanSelect);
                    }
                }
            }
            
            function addBlockLocal(blocks, tipo, destTable, cleanSelect) {
                const fromTables = [];
                
                const fromPatternBacktick = /FROM\s+`([^`]+)`/gi;
                let fromMatch;
                while ((fromMatch = fromPatternBacktick.exec(cleanSelect)) !== null) {
                    if (!fromTables.includes(fromMatch[1])) {
                        fromTables.push(fromMatch[1]);
                    }
                }
                
                const fromPatternNoBacktick = /FROM\s+([\w\-]+\.[\w\-]+\.[\w\-]+|[\w\-]+\.[\w\-]+)\s/gi;
                while ((fromMatch = fromPatternNoBacktick.exec(cleanSelect)) !== null) {
                    const tableName = fromMatch[1].trim();
                    if (!fromTables.includes(tableName) && !tableName.includes('`')) {
                        fromTables.push(tableName);
                    }
                }
                
                const joinTables = [];
                const joinsCompletos = [];
                
                const joinPatternBacktick = /(?:LEFT\s+|RIGHT\s+|INNER\s+|FULL\s+|CROSS\s+)?JOIN\s+`([^`]+)`\s+(\w+)\s+ON\s+([^\n]+?)(?=\s+(?:LEFT|RIGHT|INNER|FULL|CROSS)?\s*JOIN|\s+WHERE|\s+GROUP|\s+ORDER|\s+LIMIT|\s*$)/gi;
                let joinMatch;
                while ((joinMatch = joinPatternBacktick.exec(cleanSelect)) !== null) {
                    const tablaCompleta = joinMatch[1];
                    const tabla = tablaCompleta.split('.').pop();
                    const condicion = joinMatch[3].trim().replace(/\s+/g, ' ');
                    if (!joinTables.includes(tablaCompleta)) {
                        joinTables.push(tablaCompleta);
                        joinsCompletos.push(`${tabla} ON ${condicion}`);
                    }
                }
                
                const joinPatternNoBacktick = /(?:LEFT\s+|RIGHT\s+|INNER\s+|FULL\s+|CROSS\s+)?JOIN\s+([\w\-]+\.[\w\-]+\.[\w\-]+|[\w\-]+\.[\w\-]+)\s+(\w+)\s+ON\s+([^\n]+?)(?=\s+(?:LEFT|RIGHT|INNER|FULL|CROSS)?\s*JOIN|\s+WHERE|\s+GROUP|\s+ORDER|\s+LIMIT|\s*$)/gi;
                while ((joinMatch = joinPatternNoBacktick.exec(cleanSelect)) !== null) {
                    const tablaCompleta = joinMatch[1].trim();
                    const tabla = tablaCompleta.split('.').pop();
                    const condicion = joinMatch[3].trim().replace(/\s+/g, ' ');
                    if (!joinTables.includes(tablaCompleta) && !tablaCompleta.includes('`')) {
                        joinTables.push(tablaCompleta);
                        joinsCompletos.push(`${tabla} ON ${condicion}`);
                    }
                }
                
                const whereConditions = [];
                const whereMatch = cleanSelect.match(/WHERE\s+([\s\S]*?)(?=\s+GROUP\s+BY|\s+ORDER\s+BY|\s+LIMIT|\s*$)/i);
                if (whereMatch) {
                    const wherePart = whereMatch[1].trim()
                        .replace(/\s+/g, ' ')
                        .replace(/AND\s*$|OR\s*$/i, '')
                        .trim();
                    if (wherePart.length > 0 && wherePart.length < 500) {
                        whereConditions.push(wherePart);
                    }
                }
                
                const hasGroupBy = /GROUP\s+BY/i.test(cleanSelect);
                const hasDistinct = /SELECT\s+DISTINCT/i.test(cleanSelect);
                const hasAggregation = /\b(SUM|COUNT|AVG|MAX|MIN|ARRAY_AGG|STRING_AGG)\s*\(/i.test(cleanSelect);
                const hasTransformation = hasGroupBy || hasDistinct || hasAggregation;
                
                blocks.push({
                    tipo: tipo,
                    destino: destTable,
                    destinoNombre: destTable.split('.').pop(),
                    fuentes: fromTables,
                    joins: joinTables,
                    joinsCompletos: joinsCompletos,
                    whereConditions: whereConditions,
                    todasLasFuentes: [...new Set([...fromTables, ...joinTables])],
                    selectCompleto: cleanSelect,
                    tieneTransformacion: hasTransformation,
                    tipoTransformacion: hasGroupBy ? 'GROUP BY' : (hasDistinct ? 'DISTINCT' : (hasAggregation ? 'AGREGACION' : null)),
                    tieneWhere: whereConditions.length > 0
                });
            }
            
            const pipelineBlocks = extractPipelineBlocksLocal(allCode);
            
            // PKs
            const masterPKsInput = document.getElementById('masterPKs')?.value?.trim() || '';
            let pks = [];
            let pkPrincipal = '';
            
            if (masterPKsInput) {
                pks = masterPKsInput.split(',').map(pk => pk.trim().toUpperCase()).filter(pk => pk.length > 0);
                pkPrincipal = pks[0];
            } else {
                pks = (pipelineAnalysis.detectedPKs || []).slice(0, 5);
                pkPrincipal = pks.find(pk => pk.toUpperCase().includes('POLIZA')) 
                    || pks.find(pk => pk.toUpperCase().includes('NUMERO'))
                    || pks[0] || 'NUMERO_POLIZA';
            }
            
            const pkDisplay = pks.length > 0 ? pks.join(', ') : '(detectando automáticamente)';
            
            // Autocompletar PKs
            if (!masterPKsInput && pks.length > 0) {
                const pkInput = document.getElementById('masterPKs');
                if (pkInput) {
                    pkInput.value = pks.join(', ');
                    pkInput.style.backgroundColor = '#e8f5e9';
                }
            }
            
            // Autodetectar PKs del pipeline
            let pksAutodetectadas = [];
            pipelineBlocks.forEach(block => {
                (block.joinsCompletos || []).forEach(join => {
                    const matches = join.match(/ON\s+\w+\.(\w+)\s*=\s*\w+\.(\w+)/gi);
                    if (matches) {
                        matches.forEach(m => {
                            const parts = m.match(/ON\s+\w+\.(\w+)\s*=\s*\w+\.(\w+)/i);
                            if (parts) {
                                const campo1 = parts[1].toUpperCase();
                                const campo2 = parts[2].toUpperCase();
                                const blacklist = ['CAST', 'DATE', 'UPPER', 'LOWER', 'TRIM', 'CONCAT', 'STRING', 'INT', 'FLOAT', 'NULL', 'PK', 'DCOID', 'OPERATIONPK'];
                                if (campo1.length > 3 && !blacklist.includes(campo1) && !pksAutodetectadas.includes(campo1)) {
                                    pksAutodetectadas.push(campo1);
                                }
                                if (campo2.length > 3 && !blacklist.includes(campo2) && !pksAutodetectadas.includes(campo2)) {
                                    pksAutodetectadas.push(campo2);
                                }
                            }
                        });
                    }
                });
            });
            
            const pksIngresadas = pks.filter(pk => pk && pk.trim().length > 0);
            const pksUsuario = pksIngresadas.length > 0 ? pksIngresadas : (pksAutodetectadas.length > 0 ? pksAutodetectadas.slice(0, 3) : [pkPrincipal]);
            const pkSource = pksIngresadas.length > 0 ? 'INGRESADAS' : 'AUTODETECTADAS';
            
            const pkPipelinePrincipal = pksUsuario[0];
            const pksJoin = pksUsuario.map(pk => `o.${pk} = m.${pk}`).join(' AND ');
            const pksWhere = pksUsuario.map(pk => `m.${pk} IS NULL`).join(' AND ');
            
            // Tablas destino
            const pipelineDestinationTables = new Set();
            pipelineBlocks.forEach(block => {
                if (block.destino && block.destino !== masterTable) {
                    pipelineDestinationTables.add(block.destino);
                }
            });
            
            const tablasParaValidar = pipelineDestinationTables;
            const tablasDetectadas = [...tablasParaValidar].map(t => t.split('.').pop());
            
            // Mapa de bloques
            const blocksByDestination = {};
            pipelineBlocks.forEach(block => {
                if (block.destino) {
                    blocksByDestination[block.destino] = block;
                }
            });
            
            const cleanForSQL = (str) => {
                return str.replace(/`/g, '').replace(/'/g, '').replace(/"/g, '').replace(/\\/g, '').replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
            };
            
            // ═══════════════════════════════════════════════════════════════
            // PL-01: RESUMEN DEL PIPELINE
            // ═══════════════════════════════════════════════════════════════
            let flujoQuery = `-- ═══════════════════════════════════════════════════════════════
-- PL-01: RESUMEN DEL PIPELINE
-- Bloques detectados: ${pipelineBlocks.length}
-- ═══════════════════════════════════════════════════════════════

`;
            if (pipelineBlocks.length > 0) {
                flujoQuery += `-- CUADRE DE CADA PASO DEL PIPELINE:\n`;
                pipelineBlocks.forEach((block, i) => {
                    const fuentePrincipal = block.fuentes[0];
                    if (fuentePrincipal) {
                        const fuenteNombre = fuentePrincipal.split('.').pop();
                        const joinsInfo = block.joinsCompletos && block.joinsCompletos.length > 0 
                            ? block.joinsCompletos.join(' | ').substring(0, 200) : '-';
                        const filtrosInfo = block.whereConditions && block.whereConditions.length > 0 
                            ? block.whereConditions.join(' AND ').substring(0, 200) : '-';
                        const transformInfo = block.tieneTransformacion ? block.tipoTransformacion : '-';
                        
                        flujoQuery += `SELECT ${i + 1} as paso, 
    '${fuenteNombre}' as origen, 
    '${block.destinoNombre}' as destino,
    (SELECT COUNT(*) FROM \`${fuentePrincipal}\`) as cnt_origen,
    (SELECT COUNT(*) FROM \`${block.destino}\`) as cnt_destino,
    (SELECT COUNT(*) FROM \`${fuentePrincipal}\`) - (SELECT COUNT(*) FROM \`${block.destino}\`) as diferencia,
    CASE WHEN (SELECT COUNT(*) FROM \`${fuentePrincipal}\`) = (SELECT COUNT(*) FROM \`${block.destino}\`) THEN '✅' ELSE '⚠️' END as estado,
    '${joinsInfo.replace(/'/g, "\\'")}' as joins_on,
    '${filtrosInfo.replace(/'/g, "\\'")}' as filtros_where,
    '${transformInfo}' as transformacion`;
                        if (i < pipelineBlocks.length - 1) {
                            flujoQuery += '\nUNION ALL\n';
                        }
                    }
                });
                flujoQuery += '\nORDER BY paso;';
            } else {
                flujoQuery += `SELECT 'Sin bloques detectados' as mensaje;`;
            }

            queries.push({
                code: 'PL-01',
                title: 'Resumen Pipeline',
                query: flujoQuery
            });

            // ═══════════════════════════════════════════════════════════════
            // PL-02: REGISTROS PERDIDOS
            // ═══════════════════════════════════════════════════════════════
            let pkQuery = `-- ═══════════════════════════════════════════════════════════════
-- PL-02: REGISTROS PERDIDOS (Tablas CREATE/INSERT vs MASTER/BUSINESS)
-- PKs (${pkSource}): ${pksUsuario.join(', ')}
-- MASTER/BUSINESS: ${masterTable}
-- Tablas intermedias detectadas: ${tablasParaValidar.size}
-- Lista: ${tablasDetectadas.join(', ') || '(ninguna)'}
-- ═══════════════════════════════════════════════════════════════

`;
            if (masterTable && tablasParaValidar.size > 0) {
                pkQuery += `-- RESUMEN CONSOLIDADO:\n`;
                const summaryParts = [];
                [...tablasParaValidar].forEach(destTable => {
                    const destName = destTable.split('.').pop();
                    const block = blocksByDestination[destTable];
                    const joinsUsados = block?.joinsCompletos?.join(' | ') || 'N/A';
                    const wheresUsados = block?.whereConditions?.join(' AND ') || 'N/A';
                    const fuentesUsadas = block?.fuentes?.map(f => f.split('.').pop()).join(', ') || 'N/A';
                    const joinsEscaped = cleanForSQL(joinsUsados).substring(0, 150);
                    const wheresEscaped = cleanForSQL(wheresUsados).substring(0, 150);
                    
                    summaryParts.push(`SELECT 
    '${destName}' as tabla_origen, 
    '${masterTableName}' as master, 
    '${pksUsuario.join(', ')}' as pks_usadas,
    COUNT(*) as registros_perdidos,
    '${fuentesUsadas}' as from_usado,
    '${joinsEscaped}' as joins_usados,
    '${wheresEscaped}' as where_usados
FROM \`${destTable}\` o
LEFT JOIN \`${masterTable}\` m ON ${pksJoin}
WHERE ${pksWhere}`);
                });
                pkQuery += summaryParts.join('\nUNION ALL\n') + ';';
            } else {
                pkQuery += `SELECT 'Verifique el SP' as mensaje;`;
            }

            queries.push({
                code: 'PL-02',
                title: `Registros Perdidos (${pkPipelinePrincipal})`,
                query: pkQuery
            });

            // ═══════════════════════════════════════════════════════════════
            // PL-03: CALIDAD MASTER/BUSINESS
            // ═══════════════════════════════════════════════════════════════
            const allPks = pksUsuario;
            const pksGroupBy = allPks.join(', ');
            const pksDisplayFinal = allPks.join(', ');
            const tablasDetectadasPL04 = [...tablasParaValidar].map(t => t.split('.').pop());
            
            let resumenQuery = `-- ═══════════════════════════════════════════════════════════════
-- PL-03: CALIDAD DE DATOS EN TABLA MASTER/BUSINESS
-- PKs (${pkSource}): ${pksDisplayFinal}
-- MASTER/BUSINESS: ${masterTable}
-- Tablas intermedias detectadas: ${tablasParaValidar.size}
-- Lista: ${tablasDetectadasPL04.join(', ') || '(ninguna)'}
-- ═══════════════════════════════════════════════════════════════

`;
            if (masterTable) {
                resumenQuery += `-- 1. DUPLICADOS EN MASTER/BUSINESS:
SELECT ${pksGroupBy}, COUNT(*) as cantidad
FROM \`${masterTable}\`
GROUP BY ${pksGroupBy}
HAVING COUNT(*) > 1
ORDER BY cantidad DESC
LIMIT 100;

-- 2. NULOS EN PKs:
SELECT COUNT(*) as registros_con_pk_nula
FROM \`${masterTable}\`
WHERE ${allPks.map(pk => `${pk} IS NULL`).join(' OR ')};

-- 3. CONTEO TOTAL MASTER/BUSINESS:
SELECT 
    '${masterTableName}' as tabla,
    COUNT(*) as total_registros,
    COUNT(DISTINCT CONCAT(${allPks.map(pk => `CAST(${pk} AS STRING)`).join(", '-', ")})) as pks_unicas
FROM \`${masterTable}\`;
`;
            }
            
            if (tablasParaValidar.size > 0) {
                resumenQuery += `
-- 4. HUÉRFANOS EN MASTER/BUSINESS (registros sin origen en tablas intermedias):
`;
                const tablesArray = [...tablasParaValidar];
                let joinClauses = '';
                let whereClauses = [];
                let caseColumns = [];
                
                tablesArray.forEach((tabla, index) => {
                    const alias = `o${index + 1}`;
                    const tablaNombre = tabla.split('.').pop();
                    const joinCondition = allPks.map(pk => `m.${pk} = ${alias}.${pk}`).join(' AND ');
                    const whereCondition = allPks.map(pk => `${alias}.${pk} IS NULL`).join(' AND ');
                    
                    joinClauses += `LEFT JOIN \`${tabla}\` ${alias} ON ${joinCondition}\n`;
                    whereClauses.push(`(${whereCondition})`);
                    caseColumns.push(`    CASE WHEN ${alias}.${allPks[0]} IS NULL THEN 'NO' ELSE 'SI' END as en_${tablaNombre.substring(0, 20)}`);
                });
                
                resumenQuery += `SELECT m.*, 
${caseColumns.join(',\\n')}
FROM \`${masterTable}\` m
${joinClauses}WHERE ${whereClauses.join(' AND ')}
LIMIT 100;`;
            }

            queries.push({
                code: 'PL-03',
                title: `Calidad MASTER/BUSINESS (${pksDisplayFinal})`,
                query: resumenQuery
            });

            // Guardar queries
            generatedPipelineQueries = queries;

            // Mostrar queries
            queries.forEach((q, index) => {
                const card = document.createElement('div');
                card.className = 'query-card';
                card.innerHTML = `
                    <div class="query-header">
                        <span class="query-code">${q.code}</span>
                        <span class="query-title">${q.title}</span>
                        <button class="btn-copy" onclick="copyPipelineQuery(${index}, this)">📋 Copiar</button>
                    </div>
                    <pre class="query-content">${escapeHtml(q.query)}</pre>
                `;
                grid.appendChild(card);
            });
        }

        // ============================================
        // FIN FUNCIONES DE PIPELINE
        // ============================================

        function changeTableType() {
            currentTableType = document.getElementById('tableTypeSelect').value;
            const badge = document.getElementById('tableTypeBadge');
            const recordFields = document.getElementById('recordFields');
            const differentFields = document.getElementById('differentFields');
            const sharedPKField = document.getElementById('primaryKeys').parentElement;

            // Ocultar todos los campos especiales de tipo tabla
            recordFields.classList.remove('visible');
            differentFields.classList.remove('visible');
            sharedPKField.style.display = 'block';

            if (currentTableType === 'simple') {
                badge.textContent = 'Tabla Simple';
                badge.style.background = '#28a745';
            } else if (currentTableType === 'record') {
                badge.textContent = 'Tabla con RECORD';
                badge.style.background = '#FF6600';
                recordFields.classList.add('visible');
            } else if (currentTableType === 'different') {
                badge.textContent = 'Diferente Estructura';
                badge.style.background = '#4CAF50';
                differentFields.classList.add('visible');
                sharedPKField.style.display = 'none'; // Ocultar PK común porque se usa el mapeo
            }

            // Actualizar checkboxes "tiene bytes": mostrar en RECORD (sin importar infoType) o en encrypted
            const bytesOrigenGroup = document.getElementById('bytesOrigenGroup');
            const bytesDestinoGroup = document.getElementById('bytesDestinoGroup');
            const showBytesChecks = currentInfoType === 'encrypted' || currentTableType === 'record' || currentTableType === 'simple';
            if (bytesOrigenGroup) bytesOrigenGroup.style.display = showBytesChecks ? 'block' : 'none';
            if (bytesDestinoGroup) bytesDestinoGroup.style.display = showBytesChecks ? 'block' : 'none';

            // Si está en modo encriptado, actualizar la nota según el nuevo tipo de tabla
            if (currentInfoType === 'encrypted') {
                const encryptedTypeNote = document.getElementById('encryptedTypeNote');
                if (encryptedTypeNote) {
                    if (currentTableType === 'record') {
                        encryptedTypeNote.textContent = '📦 Tabla con RECORD: se usa la columna RECORD configurada arriba (origen y destino). Los campos BYTES se buscan dentro de ese RECORD con UNNEST.';
                    } else {
                        encryptedTypeNote.textContent = '📋 Tabla Simple/Diferente Estructura: los campos BYTES son columnas top-level. Las consultas acceden directamente sin UNNEST.';
                    }
                }
            }

            document.getElementById('queriesGrid').innerHTML = '';
        }

        function changeInfoType() {
            currentInfoType = document.getElementById('infoTypeSelect').value;
            const encryptedFields = document.getElementById('encryptedFields');
            const sharedPKField = document.getElementById('primaryKeys').parentElement;
            const infoBadge = document.getElementById('infoTypeBadge');
            const bytesOrigenGroup = document.getElementById('bytesOrigenGroup');
            const bytesDestinoGroup = document.getElementById('bytesDestinoGroup');
            const encryptedTypeNote = document.getElementById('encryptedTypeNote');

            // Determinar si mostrar checkboxes: siempre en encrypted, y también en RECORD+clear
            const showBytesChecks = currentInfoType === 'encrypted' || currentTableType === 'record' || currentTableType === 'simple';

            if (currentInfoType === 'encrypted') {
                // Mostrar sección info encriptado
                if (encryptedFields) encryptedFields.classList.add('visible');
                // No se necesita PK para encriptadas
                sharedPKField.style.display = 'none';
                if (infoBadge) { infoBadge.textContent = '🔐 Encriptado'; infoBadge.style.display = 'inline'; infoBadge.style.background = '#7B1FA2'; }
                // Nota según tipo de tabla
                if (encryptedTypeNote) {
                    if (currentTableType === 'record') {
                        encryptedTypeNote.textContent = '📦 Tabla con RECORD: se usa la columna RECORD configurada arriba (origen y destino). Los campos BYTES se buscan dentro de ese RECORD con UNNEST.';
                    } else {
                        encryptedTypeNote.textContent = '📋 Tabla Simple/Diferente Estructura: los campos BYTES son columnas top-level. Las consultas acceden directamente sin UNNEST.';
                    }
                }
            } else {
                if (encryptedFields) encryptedFields.classList.remove('visible');
                // Restaurar visibilidad de PK según tipo de tabla
                sharedPKField.style.display = currentTableType === 'different' ? 'none' : 'block';
                if (infoBadge) infoBadge.style.display = 'none';
            }

            // Mostrar/ocultar checkboxes según combinación
            if (bytesOrigenGroup) bytesOrigenGroup.style.display = showBytesChecks ? 'block' : 'none';
            if (bytesDestinoGroup) bytesDestinoGroup.style.display = showBytesChecks ? 'block' : 'none';

            document.getElementById('queriesGrid').innerHTML = '';
        }

        function validateForm() {
            let isValid = true;
            let requiredFields = [];

            // Campos requeridos según el modo
            requiredFields = [
                'proyectoOrigen', 'datasetOrigen', 'tablaOrigen',
                'proyectoDestino', 'datasetDestino', 'tablaDestino'
            ];

            // PKs según el tipo de tabla e información
            if (currentInfoType === 'encrypted') {
                // No se requiere PK para encriptadas; si es RECORD, se requiere columna RECORD
                if (currentTableType === 'record') {
                    requiredFields.push('recordColumnOrigen', 'recordColumnDestino');
                }
            } else if (currentTableType === 'different') {
                requiredFields.push('pkOrigen', 'pkDestino');
            } else {
                requiredFields.push('primaryKeys');
                if (currentTableType === 'record') {
                    requiredFields.push('recordColumnOrigen', 'recordColumnDestino');
                }
            }

            document.querySelectorAll('.form-group input, .form-group textarea').forEach(input => {
                input.classList.remove('error');
                const errorMsg = input.parentElement.querySelector('.error-message');
                if (errorMsg) errorMsg.style.display = 'none';
            });

            requiredFields.forEach(fieldId => {
                const field = document.getElementById(fieldId);
                if (field && !field.value.trim()) {
                    field.classList.add('error');
                    const errorMsg = field.parentElement.querySelector('.error-message');
                    if (errorMsg) errorMsg.style.display = 'block';
                    isValid = false;
                }
            });

            // Validación adicional: mismo número de PKs en origen y destino
            if (currentInfoType !== 'encrypted' && currentTableType === 'different') {
                const pkOrigenCount = document.getElementById('pkOrigen').value.split(',').filter(p => p.trim()).length;
                const pkDestinoCount = document.getElementById('pkDestino').value.split(',').filter(p => p.trim()).length;
                if (pkOrigenCount !== pkDestinoCount) {
                    alert('⚠️ La cantidad de PKs en origen debe ser igual a la cantidad en destino');
                    isValid = false;
                }

                // Validar campos a comparar si ambos tienen valor
                const camposOrigen = document.getElementById('camposOrigen').value.trim();
                const camposDestino = document.getElementById('camposDestino').value.trim();
                if (camposOrigen && camposDestino) {
                    const camposOrigenCount = camposOrigen.split(',').filter(p => p.trim()).length;
                    const camposDestinoCount = camposDestino.split(',').filter(p => p.trim()).length;
                    if (camposOrigenCount !== camposDestinoCount) {
                        alert('⚠️ La cantidad de campos a comparar en origen debe ser igual a la cantidad en destino');
                        isValid = false;
                    }
                }
            }

            const alertEl = document.getElementById('validationAlert');
            if (!isValid) {
                alertEl.classList.add('visible');
            } else {
                alertEl.classList.remove('visible');
            }

            return isValid;
        }

        function getInputValues() {
            const values = {
                primaryKeys: document.getElementById('primaryKeys').value || 'id',
                proyectoOrigen: document.getElementById('proyectoOrigen').value || 'PROYECTO_ORIGEN',
                datasetOrigen: document.getElementById('datasetOrigen').value || 'DATASET_ORIGEN',
                tablaOrigen: document.getElementById('tablaOrigen').value || 'TABLA_ORIGEN',
                filtroOrigen: document.getElementById('filtroOrigen').value || '',
                joinOrigen: document.getElementById('joinOrigen').value || '',
                proyectoDestino: document.getElementById('proyectoDestino').value || 'PROYECTO_DESTINO',
                datasetDestino: document.getElementById('datasetDestino').value || 'DATASET_DESTINO',
                tablaDestino: document.getElementById('tablaDestino').value || 'TABLA_DESTINO',
                filtroDestino: document.getElementById('filtroDestino').value || '',
                joinDestino: document.getElementById('joinDestino').value || '',
                recordColumnOrigen: document.getElementById('recordColumnOrigen').value || 'RECORD_COL',
                recordColumnDestino: document.getElementById('recordColumnDestino').value || 'RECORD_COL',
                // Campos para diferente estructura
                pkOrigen: document.getElementById('pkOrigen').value || '',
                pkDestino: document.getElementById('pkDestino').value || '',
                camposOrigen: document.getElementById('camposOrigen').value || '',
                camposDestino: document.getElementById('camposDestino').value || '',
                // Checkboxes "tiene bytes" (para modo Encriptado)
                origenHasBytes: document.getElementById('origenHasBytes') ? document.getElementById('origenHasBytes').checked : false,
                destinoHasBytes: document.getElementById('destinoHasBytes') ? document.getElementById('destinoHasBytes').checked : false
            };

            // Si es tipo "different" y no encriptado, usar los PKs mapeados
            if (currentInfoType !== 'encrypted' && currentTableType === 'different') {
                values.pkListOrigen = values.pkOrigen.split(',').map(p => p.trim()).filter(p => p);
                values.pkListDestino = values.pkDestino.split(',').map(p => p.trim()).filter(p => p);
                values.camposListOrigen = values.camposOrigen ? values.camposOrigen.split(',').map(p => p.trim()).filter(p => p) : [];
                values.camposListDestino = values.camposDestino ? values.camposDestino.split(',').map(p => p.trim()).filter(p => p) : [];
            }

            return values;
        }


        function generateUTQueries(v) {
            const pkList = v.primaryKeys.split(',').map(p => p.trim()).filter(p => p);
            const pkColumns = pkList.join(', ');
            const pkJoinCondition = pkList.map(pk => `o.${pk} = d.${pk}`).join(' AND ');

            const whereOrigen = v.filtroOrigen ? `WHERE ${v.filtroOrigen}` : '';
            const whereDestino = v.filtroDestino ? `WHERE ${v.filtroDestino}` : '';

            // Filtro data_type para INFORMATION_SCHEMA (controlado por checkboxes "tiene bytes")
            // En claro: excluir BYTES (!=); Encriptado: incluir solo BYTES (=)
            const bytesOpUT = currentInfoType === 'encrypted' ? "= 'BYTES'" : "!= 'BYTES'";
            const bytesFilterOrigen = v.origenHasBytes ? `\n    AND data_type ${bytesOpUT}` : '';
            const bytesFilterDestino = v.destinoHasBytes ? `\n    AND data_type ${bytesOpUT}` : '';

            const queries = [];

            // UT-01: Conteo de registros con diferencia y estado
            queries.push({
                code: 'UT-01',
                title: 'Conteo de Registros',
                description: 'Valida que la cantidad de registros sea igual entre ORIGEN y DESTINO',
                isAuxiliary: false,
                query: `-- UT-01: Conteo de Registros (ORIGEN vs DESTINO)
-- Resultado esperado: diferencia = 0, estado = PASS

WITH conteos AS (
    SELECT 
        (SELECT COUNT(*) FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.${v.tablaOrigen}\` o
         ${v.joinOrigen ? v.joinOrigen + ' ' : ''}${whereOrigen}) as cnt_origen,
        (SELECT COUNT(*) FROM \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\` d
         ${v.joinDestino ? v.joinDestino + ' ' : ''}${whereDestino}) as cnt_destino
)
SELECT 
    cnt_origen as registros_origen,
    cnt_destino as registros_destino,
    cnt_origen - cnt_destino as diferencia,
    CASE 
        WHEN cnt_origen = cnt_destino THEN 'PASS'
        ELSE 'FAIL'
    END as estado
FROM conteos;`
            });

            // UT-02 depende del tipo de tabla
            if (currentTableType === 'simple') {
                // UT-02 AUXILIAR para tabla simple
                queries.push({
                    code: 'UT-02-AUX',
                    title: 'UT-02 Auxiliar: Obtener Columnas para Duplicados',
                    description: 'PASO 1: Ejecutar primero para obtener las columnas del destino',
                    isAuxiliary: true,
                    query: `-- UT-02 AUXILIAR: Obtener columnas para validar duplicados
-- PASO 1: Ejecutar este query y copiar el resultado 'columnas_group'

SELECT 
    STRING_AGG(column_name, ', ') as columnas_group
FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMNS\`
WHERE table_name = '${v.tablaDestino}'
  AND data_type NOT IN ('ARRAY', 'STRUCT', 'RECORD', 'GEOGRAPHY', 'JSON')${bytesFilterDestino};`
                });

                // UT-02 FINAL para tabla simple
                queries.push({
                    code: 'UT-02-FINAL',
                    title: 'UT-02 Final: Valores Únicos (Todos los Campos)',
                    description: 'PASO 2: Reemplazar <<COLUMNAS>> con el resultado del query auxiliar',
                    isAuxiliary: false,
                    query: `-- UT-02 FINAL: Valores Únicos - Duplicados en TODOS los campos
-- PASO 2: Reemplazar <<COLUMNAS>> con 'columnas_group' del query auxiliar
-- Resultado esperado: 0 registros (sin duplicados)

SELECT 
    <<COLUMNAS>>,
    COUNT(*) as ocurrencias
FROM \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\` d
${v.joinDestino ? v.joinDestino + '\n' : ''}${whereDestino}
GROUP BY <<COLUMNAS>>
HAVING COUNT(*) > 1
ORDER BY ocurrencias DESC
LIMIT 100;`
                });
            } else {
                // UT-02 AUXILIAR para tabla con RECORD
                queries.push({
                    code: 'UT-02-AUX',
                    title: 'UT-02 Auxiliar: Obtener Campos RECORD para Duplicados',
                    description: 'PASO 1: Ejecutar primero para obtener campos del RECORD',
                    isAuxiliary: true,
                    query: `-- UT-02 AUXILIAR: Obtener campos del RECORD para validar duplicados
-- PASO 1: Ejecutar este query y copiar el resultado 'columnas_todas'

DECLARE record_col STRING DEFAULT '${v.recordColumnDestino}';

WITH campos_record AS (
    SELECT 
        REPLACE(field_path, CONCAT(record_col, '.'), '') as campo
    FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMN_FIELD_PATHS\`
    WHERE table_name = '${v.tablaDestino}'
      AND column_name = record_col
      AND field_path != record_col${bytesFilterDestino}
),
campos_base AS (
    SELECT column_name as campo
    FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMNS\`
    WHERE table_name = '${v.tablaDestino}'
      AND data_type NOT IN ('ARRAY', 'STRUCT', 'RECORD')${bytesFilterDestino}
)
SELECT 
    CONCAT(
        (SELECT STRING_AGG(CONCAT('t.', campo), ', ') FROM campos_base),
        ', ',
        (SELECT STRING_AGG(CONCAT('r.', campo), ', ') FROM campos_record)
    ) as columnas_todas;`
                });

                // UT-02 FINAL para tabla con RECORD
                queries.push({
                    code: 'UT-02-FINAL',
                    title: 'UT-02 Final: Valores Únicos (RECORD)',
                    description: 'PASO 2: Reemplazar <<COLUMNAS>> con columnas_todas del auxiliar',
                    isAuxiliary: false,
                    query: `-- UT-02 FINAL: Valores Únicos - Duplicados en campos RECORD
-- PASO 2: Reemplazar <<COLUMNAS>> con 'columnas_todas' del query auxiliar
-- Resultado esperado: 0 registros (sin duplicados)

SELECT 
    <<COLUMNAS>>,
    COUNT(*) as ocurrencias
FROM \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\` t
LEFT JOIN UNNEST(t.${v.recordColumnDestino}) r
${v.joinDestino ? v.joinDestino + '\n' : ''}${whereDestino}
GROUP BY <<COLUMNAS>>
HAVING COUNT(*) > 1
ORDER BY ocurrencias DESC
LIMIT 100;`
                });
            }

            // UT-03: Integridad - Queries de 2 pasos
            const filtroOrigenOneLine = v.filtroOrigen ? v.filtroOrigen.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim() : '';
            const filtroDestinoOneLine = v.filtroDestino ? v.filtroDestino.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim() : '';
            
            if (currentTableType === 'simple') {
                // UT-03 AUXILIAR para tabla simple
                queries.push({
                    code: 'UT-03-AUX',
                    title: 'UT-03 Auxiliar: Generar Bloque de Columnas',
                    description: 'PASO 1: Ejecutar primero para obtener el bloque de comparación',
                    isAuxiliary: true,
                    query: `-- UT-03 AUXILIAR: Generar bloque de columnas para comparar
-- PASO 1: Ejecutar este query y copiar el resultado 'bloque'

WITH ORIGEN AS (
  SELECT column_name
  FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.INFORMATION_SCHEMA.COLUMNS\`
  WHERE table_name = '${v.tablaOrigen}'${bytesFilterOrigen}
), 
DESTINO AS (
  SELECT column_name
  FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMNS\`
  WHERE table_name = '${v.tablaDestino}'${bytesFilterDestino}
)
SELECT 
  STRING_AGG(
    CONCAT(
      'A.', a.column_name, ' AS valor_origen_', a.column_name, ', ',
      'B.', b.column_name, ' AS valor_destino_', b.column_name, ', ',
      "CASE WHEN A.", a.column_name, " IS NULL AND B.", b.column_name, " IS NULL THEN 'IGUAL' ",
      "WHEN UPPER(TRIM(CAST(A.", a.column_name, " AS STRING))) = UPPER(TRIM(CAST(B.", b.column_name, " AS STRING))) THEN 'IGUAL' ",
      "ELSE 'DIFERENTE' END AS estado_", a.column_name
    ),
    ', '
  ) AS bloque 
FROM ORIGEN a  
JOIN DESTINO b ON UPPER(a.column_name) = UPPER(b.column_name);`
                });

                // UT-03 FINAL para tabla simple
                queries.push({
                    code: 'UT-03-FINAL',
                    title: 'UT-03 Final: Integridad Bidireccional',
                    description: 'PASO 2: Pegar el bloque generado donde indica',
                    isAuxiliary: false,
                    query: `-- UT-03 FINAL: Integridad Bidireccional (FULL OUTER JOIN)
-- PASO 2: Pegar el 'bloque' del query auxiliar donde indica
-- Resultado esperado: 0 registros con diferencias
-- NOTA: Si desea obtener el total de diferencias, quitar el LIMIT 1000

WITH
  origen AS (
    SELECT * FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.${v.tablaOrigen}\` o
    ${v.joinOrigen ? v.joinOrigen + '\n    ' : ''}${filtroOrigenOneLine ? 'WHERE ' + filtroOrigenOneLine : ''}
  ),
  destino AS (
    SELECT * FROM \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\` d
    ${v.joinDestino ? v.joinDestino + '\n    ' : ''}${filtroDestinoOneLine ? 'WHERE ' + filtroDestinoOneLine : ''}
  )
SELECT DISTINCT
    ${pkList.map(pk => `COALESCE(CAST(A.${pk} AS STRING), CAST(B.${pk} AS STRING)) AS ${pk}`).join(',\n    ')},
    -- ═══════════════════════════════════════════════════════════════
    -- PEGAR AQUÍ EL 'bloque' DEL QUERY UT-03-AUX
    -- Ejemplo:
    -- A.campo1 AS valor_origen_campo1,
    -- B.campo1 AS valor_destino_campo1,
    -- CASE WHEN A.campo1 IS NULL AND B.campo1 IS NULL THEN 'IGUAL' ... END AS estado_campo1,
    -- ═══════════════════════════════════════════════════════════════
FROM origen A
FULL OUTER JOIN destino B
    ON ${pkList.map(pk => `CAST(A.${pk} AS STRING) = CAST(B.${pk} AS STRING)`).join(' AND ')}
ORDER BY 1
LIMIT 1000;`
                });
            } else {
                // UT-03 AUXILIAR para tabla con RECORD
                queries.push({
                    code: 'UT-03-AUX',
                    title: 'UT-03 Auxiliar: Obtener Campos RECORD para Comparar',
                    description: 'PASO 1: Ejecutar primero para obtener campos del RECORD',
                    isAuxiliary: true,
                    query: `-- UT-03 AUXILIAR: Obtener campos del RECORD para comparar
-- PASO 1: Ejecutar este query y copiar el resultado 'bloque'

DECLARE record_col_origen STRING DEFAULT '${v.recordColumnOrigen}';
DECLARE record_col_destino STRING DEFAULT '${v.recordColumnDestino}';

WITH ORIGEN AS (
  SELECT field_path 
  FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.INFORMATION_SCHEMA.COLUMN_FIELD_PATHS\`
  WHERE table_name = '${v.tablaOrigen}' 
    AND column_name = record_col_origen
    AND field_path != record_col_origen${bytesFilterOrigen}
), 
DESTINO AS (
  SELECT field_path 
  FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMN_FIELD_PATHS\`
  WHERE table_name = '${v.tablaDestino}'
    AND column_name = record_col_destino
    AND field_path != record_col_destino${bytesFilterDestino}
)
SELECT 
  STRING_AGG(
    CONCAT(
      'oa.', REPLACE(a.field_path, CONCAT(record_col_origen, '.'), ''), 
      ' AS origen_', REPLACE(a.field_path, '.', '_'), ', ',
      'da.', REPLACE(b.field_path, CONCAT(record_col_destino, '.'), ''), 
      ' AS destino_', REPLACE(b.field_path, '.', '_'), ', ',
      "CASE WHEN oa.", REPLACE(a.field_path, CONCAT(record_col_origen, '.'), ''), 
      " IS NULL AND da.", REPLACE(b.field_path, CONCAT(record_col_destino, '.'), ''), 
      " IS NULL THEN 'IGUAL' WHEN CAST(oa.", REPLACE(a.field_path, CONCAT(record_col_origen, '.'), ''), 
      " AS STRING) = CAST(da.", REPLACE(b.field_path, CONCAT(record_col_destino, '.'), ''), 
      " AS STRING) THEN 'IGUAL' ELSE 'DIFERENTE' END AS estado_", 
      REPLACE(a.field_path, '.', '_')
    ),
    ',\\n'
  ) AS bloque 
FROM ORIGEN a  
JOIN DESTINO b ON UPPER(a.field_path) = UPPER(b.field_path);`
                });

                // UT-03 FINAL para tabla con RECORD
                queries.push({
                    code: 'UT-03-FINAL',
                    title: 'UT-03 Final: Integridad Bidireccional (RECORD)',
                    description: 'PASO 2: Reemplazar <<BLOQUE>> con el resultado del auxiliar',
                    isAuxiliary: false,
                    query: `-- UT-03 FINAL: Integridad Bidireccional (RECORD/ARRAY)
-- PASO 2: Reemplazar <<BLOQUE>> con el resultado del query auxiliar
-- Resultado esperado: 0 registros con diferencias

WITH
  origen AS (
    SELECT * FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.${v.tablaOrigen}\` o
    ${v.joinOrigen ? v.joinOrigen + '\n    ' : ''}${v.filtroOrigen ? 'WHERE ' + v.filtroOrigen : ''}
  ),
  destino AS (
    SELECT * FROM \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\` d
    ${v.joinDestino ? v.joinDestino + '\n    ' : ''}${v.filtroDestino ? 'WHERE ' + v.filtroDestino : ''}
  )
SELECT DISTINCT
    ${pkList.map(pk => `COALESCE(CAST(o.${pk} AS STRING), CAST(d.${pk} AS STRING)) AS ${pk}`).join(',\n    ')},
    CASE 
        WHEN o.${pkList[0]} IS NULL THEN 'SOLO_DESTINO'
        WHEN d.${pkList[0]} IS NULL THEN 'SOLO_ORIGEN'
        ELSE 'DIFERENTE'
    END as tipo_diferencia,
    <<BLOQUE>>
FROM origen o
LEFT JOIN UNNEST(o.${v.recordColumnOrigen}) oa
FULL OUTER JOIN destino d
    ON ${pkList.map(pk => `CAST(o.${pk} AS STRING) = CAST(d.${pk} AS STRING)`).join(' AND ')}
LEFT JOIN UNNEST(d.${v.recordColumnDestino}) da
ORDER BY 1
LIMIT 1000;`
                });
            }


            // UT-04: Resumen de Diferencias campo a campo (2 pasos)
            if (currentTableType === 'simple') {
                queries.push({
                    code: 'UT-04-AUX',
                    title: 'UT-04 Auxiliar: Generar Bloques de Comparaci\u00f3n',
                    description: 'PASO 1: Ejecutar primero para obtener bloque_diff y bloque_sum',
                    isAuxiliary: true,
                    query: `-- UT-04 AUXILIAR: Generar bloques para Resumen de Diferencias
-- PASO 1: Ejecutar y copiar 'bloque_diff' y 'bloque_sum'
-- bloque_diff: va dentro del SELECT del CTE joined
-- bloque_sum: va en el SELECT final

WITH ORIGEN AS (
  SELECT column_name
  FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.INFORMATION_SCHEMA.COLUMNS\`
  WHERE table_name = '${v.tablaOrigen}'
    AND data_type NOT IN ('ARRAY', 'STRUCT', 'RECORD')${bytesFilterOrigen}
),
DESTINO AS (
  SELECT column_name
  FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMNS\`
  WHERE table_name = '${v.tablaDestino}'
    AND data_type NOT IN ('ARRAY', 'STRUCT', 'RECORD')${bytesFilterDestino}
)
SELECT
  STRING_AGG(
    CONCAT(
      "CASE WHEN COALESCE(CAST(A.", a.column_name, " AS STRING), '') = COALESCE(CAST(B.", b.column_name, " AS STRING), '') THEN 0 ELSE 1 END AS diff_", a.column_name
    ),
    ',\\n'
  ) AS bloque_diff,
  STRING_AGG(
    CONCAT("SUM(diff_", a.column_name, ") AS dif_", a.column_name),
    ',\\n'
  ) AS bloque_sum
FROM ORIGEN a
JOIN DESTINO b ON UPPER(a.column_name) = UPPER(b.column_name);`
                });

                queries.push({
                    code: 'UT-04-FINAL',
                    title: 'UT-04 Final: Resumen de Diferencias',
                    description: 'PASO 2: Pegar bloque_diff y bloque_sum donde indica',
                    isAuxiliary: false,
                    query: `-- UT-04 FINAL: Resumen de Diferencias campo a campo
-- PASO 2: Pegar 'bloque_diff' y 'bloque_sum' donde indica
-- Resultado esperado: dif_CAMPO = 0 para todos los campos (sin diferencias)

WITH
  origen AS (
    SELECT * FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.${v.tablaOrigen}\` o
    ${v.joinOrigen ? v.joinOrigen + '\n    ' : ''}${filtroOrigenOneLine ? 'WHERE ' + filtroOrigenOneLine : ''}
  ),
  destino AS (
    SELECT * FROM \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\` d
    ${v.joinDestino ? v.joinDestino + '\n    ' : ''}${filtroDestinoOneLine ? 'WHERE ' + filtroDestinoOneLine : ''}
  ),
  joined AS (
    SELECT
      ${pkList.map(pk => `COALESCE(CAST(A.${pk} AS STRING), CAST(B.${pk} AS STRING)) AS ${pk}`).join(',\n      ')},
      -- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550
      -- PEGAR AQU\u00cd EL 'bloque_diff' DEL QUERY UT-04-AUX
      -- Ejemplo:
      -- CASE WHEN COALESCE(CAST(A.campo AS STRING), '') = COALESCE(CAST(B.campo AS STRING), '') THEN 0 ELSE 1 END AS diff_campo,
      -- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550
    FROM origen A
    FULL OUTER JOIN destino B
      ON ${pkList.map(pk => `CAST(A.${pk} AS STRING) = CAST(B.${pk} AS STRING)`).join(' AND ')}
  )
SELECT
  COUNT(1) AS total_registros,
  -- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550
  -- PEGAR AQU\u00cd EL 'bloque_sum' DEL QUERY UT-04-AUX
  -- Ejemplo:
  -- SUM(diff_campo) AS dif_campo,
  -- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550
FROM joined;`
                });
            } else {
                // UT-04 para tabla RECORD
                queries.push({
                    code: 'UT-04-AUX',
                    title: 'UT-04 Auxiliar: Generar Bloques de Comparaci\u00f3n (RECORD)',
                    description: 'PASO 1: Ejecutar primero para obtener bloque_diff y bloque_sum',
                    isAuxiliary: true,
                    query: `-- UT-04 AUXILIAR: Generar bloques para Resumen de Diferencias (RECORD)
-- PASO 1: Ejecutar y copiar 'bloque_diff' y 'bloque_sum' (solo campos RECORD + PKs)

DECLARE record_col_origen STRING DEFAULT '${v.recordColumnOrigen}';
DECLARE record_col_destino STRING DEFAULT '${v.recordColumnDestino}';

WITH campos_record_origen AS (
  SELECT REPLACE(field_path, CONCAT(record_col_origen, '.'), '') as campo
  FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.INFORMATION_SCHEMA.COLUMN_FIELD_PATHS\`
  WHERE table_name = '${v.tablaOrigen}' AND column_name = record_col_origen AND field_path != record_col_origen${bytesFilterOrigen}
),
campos_record_destino AS (
  SELECT REPLACE(field_path, CONCAT(record_col_destino, '.'), '') as campo
  FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMN_FIELD_PATHS\`
  WHERE table_name = '${v.tablaDestino}' AND column_name = record_col_destino AND field_path != record_col_destino${bytesFilterDestino}
)
SELECT
  STRING_AGG(
    CONCAT("CASE WHEN COALESCE(CAST(oa.", a.campo, " AS STRING), '') = COALESCE(CAST(da.", b.campo, " AS STRING), '') THEN 0 ELSE 1 END AS diff_", a.campo),
    ',\\n'
  ) AS bloque_diff,
  STRING_AGG(
    CONCAT("SUM(diff_", a.campo, ") AS dif_", a.campo),
    ',\\n'
  ) AS bloque_sum
FROM campos_record_origen a
JOIN campos_record_destino b ON UPPER(a.campo) = UPPER(b.campo);`
                });

                queries.push({
                    code: 'UT-04-FINAL',
                    title: 'UT-04 Final: Resumen de Diferencias (RECORD)',
                    description: 'PASO 2: Pegar bloque_diff y bloque_sum donde indica',
                    isAuxiliary: false,
                    query: `-- UT-04 FINAL: Resumen de Diferencias campo a campo (RECORD)
-- PASO 2: Pegar 'bloque_diff' y 'bloque_sum' donde indica
-- Resultado esperado: dif_CAMPO = 0 para todos (sin diferencias)

WITH
  origen AS (
    SELECT * FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.${v.tablaOrigen}\` o
    ${v.joinOrigen ? v.joinOrigen + '\n    ' : ''}${v.filtroOrigen ? 'WHERE ' + v.filtroOrigen : ''}
  ),
  destino AS (
    SELECT * FROM \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\` d
    ${v.joinDestino ? v.joinDestino + '\n    ' : ''}${v.filtroDestino ? 'WHERE ' + v.filtroDestino : ''}
  ),
  joined AS (
    SELECT
      ${pkList.map(pk => `COALESCE(CAST(A.${pk} AS STRING), CAST(B.${pk} AS STRING)) AS ${pk}`).join(',\n      ')},
      -- PEGAR AQU\u00cd EL 'bloque_diff' (campos base + campos RECORD)
    FROM origen A
    LEFT JOIN UNNEST(A.${v.recordColumnOrigen}) oa
    FULL OUTER JOIN destino B
      ON ${pkList.map(pk => `CAST(A.${pk} AS STRING) = CAST(B.${pk} AS STRING)`).join(' AND ')}
    LEFT JOIN UNNEST(B.${v.recordColumnDestino}) da
  )
SELECT
  COUNT(1) AS total_registros,
  -- PEGAR AQU\u00cd EL 'bloque_sum'
FROM joined;`
                });
            }

            return queries;
        }

        function generateQAQueries(v) {
            const pkList = v.primaryKeys.split(',').map(p => p.trim()).filter(p => p);
            const pkColumns = pkList.join(', ');
            const pkJoinCondition = pkList.map(pk => `o.${pk} = d.${pk}`).join(' AND ');

            const whereOrigen = v.filtroOrigen ? `WHERE ${v.filtroOrigen}` : '';
            const whereDestino = v.filtroDestino ? `WHERE ${v.filtroDestino}` : '';

            // Filtro data_type para INFORMATION_SCHEMA (controlado por checkboxes "tiene bytes")
            // En claro: excluir BYTES (!=); Encriptado: incluir solo BYTES (=)
            const bytesOpStr = currentInfoType === 'encrypted' ? "= 'BYTES'" : "!= 'BYTES'";
            const bytesFilterOrigen = v.origenHasBytes ? `\n    AND data_type ${bytesOpStr}` : '';
            const bytesFilterDestino = v.destinoHasBytes ? `\n    AND data_type ${bytesOpStr}` : '';

            const queries = [];

            // R01: Existencia de tabla con fecha creación/actualización
            queries.push({
                code: 'R01',
                title: 'Existencia de Tabla',
                description: 'Valida que la tabla existe en el destino con fechas de creación/actualización',
                isAuxiliary: false,
                query: `-- R01: Existencia de Tabla con Metadatos
-- Resultado esperado: 1 registro con estado EXISTE

SELECT 
    project_id as proyecto,
    dataset_id as dataset,
    table_id as tabla,
    DATE(TIMESTAMP_MILLIS(creation_time)) as fecha_creacion,
    TIMESTAMP_MILLIS(last_modified_time) as fecha_actualizacion,
    row_count as cantidad_registros,
    ROUND(size_bytes / 1024 / 1024, 2) as tamano_mb,
    'EXISTE' as estado
FROM \`${v.proyectoDestino}.${v.datasetDestino}.__TABLES__\`
WHERE table_id = '${v.tablaDestino}';`
            });

            // R02: Cabeceras iguales
            queries.push({
                code: 'R02',
                title: 'Cabeceras Iguales',
                description: 'Valida que las columnas sean iguales entre ORIGEN y DESTINO',
                isAuxiliary: false,
                query: `-- R02: Cabeceras Iguales (Columnas)
-- Resultado esperado: 0 registros (todas las columnas en ambas)

SELECT 
    COALESCE(o.column_name, d.column_name) as columna,
    o.column_name as en_origen,
    d.column_name as en_destino,
    CASE 
        WHEN o.column_name IS NULL THEN 'SOLO_DESTINO'
        WHEN d.column_name IS NULL THEN 'SOLO_ORIGEN'
        ELSE 'AMBAS' 
    END as ubicacion
FROM (
    SELECT column_name 
    FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.INFORMATION_SCHEMA.COLUMNS\` 
    WHERE table_name = '${v.tablaOrigen}'
) o
FULL OUTER JOIN (
    SELECT column_name 
    FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMNS\` 
    WHERE table_name = '${v.tablaDestino}'
) d ON UPPER(o.column_name) = UPPER(d.column_name)
WHERE o.column_name IS NULL OR d.column_name IS NULL;`
            });

            // R03: Tipos de datos
            queries.push({
                code: 'R03',
                title: 'Tipos de Datos',
                description: 'Valida que los tipos de datos sean correctos',
                isAuxiliary: false,
                query: `-- R03: Tipos de Datos
-- Resultado esperado: 0 registros (todos los tipos coinciden)

SELECT 
    COALESCE(o.column_name, d.column_name) as columna,
    o.data_type as tipo_origen,
    d.data_type as tipo_destino,
    CASE WHEN o.data_type = d.data_type THEN 'OK' ELSE 'DIFERENTE' END as estado
FROM (
    SELECT column_name, data_type 
    FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.INFORMATION_SCHEMA.COLUMNS\` 
    WHERE table_name = '${v.tablaOrigen}'
) o
FULL OUTER JOIN (
    SELECT column_name, data_type 
    FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMNS\` 
    WHERE table_name = '${v.tablaDestino}'
) d ON UPPER(o.column_name) = UPPER(d.column_name)
WHERE o.data_type != d.data_type OR o.column_name IS NULL OR d.column_name IS NULL;`
            });

            // R04: Conteo de registros con diferencia y estado
            queries.push({
                code: 'R04',
                title: 'Conteo de Registros',
                description: 'Valida que el conteo sea igual entre ORIGEN y DESTINO',
                isAuxiliary: false,
                query: `-- R04: Conteo de Registros
-- Resultado esperado: diferencia = 0, estado = PASS

WITH conteos AS (
    SELECT 
        (SELECT COUNT(*) FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.${v.tablaOrigen}\` ${whereOrigen}) as cnt_origen,
        (SELECT COUNT(*) FROM \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\` ${whereDestino}) as cnt_destino
)
SELECT 
cnt_origen as registros_origen,
        cnt_destino as registros_destino,
        cnt_origen - cnt_destino as diferencia,
    CASE 
        WHEN cnt_origen = cnt_destino THEN 'PASS'
        ELSE 'FAIL'
    END as estado
FROM conteos;`
            });

            // R05 con EXECUTE IMMEDIATE (un solo paso)
            // Remover saltos de línea del filtro para evitar errores de sintaxis
            const filtroR05Simple = v.filtroDestino ? ` WHERE ${v.filtroDestino.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim()}` : '';
            
            if (currentTableType === 'simple') {
                queries.push({
                    code: 'R05',
                    title: 'Campos No Nulos',
                    description: 'Valida que los campos no tengan valores nulos (usa EXECUTE IMMEDIATE)',
                    isAuxiliary: false,
                    query: `-- R05: Campos No Nulos (en DESTINO) - EXECUTE IMMEDIATE
-- Resultado esperado: estado = PASS para cada campo (nulos = 0)

DECLARE query_nulos STRING;

SET query_nulos = (
    SELECT STRING_AGG(
        CONCAT(
            "SELECT '", column_name, "' as campo, COUNT(*) as total, ",
            "COUNTIF(", column_name, " IS NULL) as nulos, ",
            "ROUND(COUNTIF(", column_name, " IS NULL) * 100.0 / COUNT(*), 2) as pct_nulos, ",
            "CASE WHEN COUNTIF(", column_name, " IS NULL) = 0 THEN 'PASS' ELSE 'FAIL' END as estado ",
            "FROM \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\`${filtroR05Simple}"
        ),
        ' UNION ALL '
    )
    FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMNS\`
    WHERE table_name = '${v.tablaDestino}'
      AND is_nullable = 'YES'${bytesFilterDestino}
      AND data_type NOT IN ('ARRAY', 'STRUCT', 'RECORD')
);

EXECUTE IMMEDIATE query_nulos;`
                });
            } else {
                // Remover saltos de línea del filtro para evitar errores de sintaxis
                const filtroR05 = v.filtroDestino ? `WHERE ${v.filtroDestino.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim()}` : '';
                queries.push({
                    code: 'R05',
                    title: 'Campos No Nulos (RECORD)',
                    description: 'Valida que los campos del RECORD no tengan valores nulos (usa EXECUTE IMMEDIATE)',
                    isAuxiliary: false,
                    query: `-- R05: Campos No Nulos - RECORD (en DESTINO) - EXECUTE IMMEDIATE
-- Resultado esperado: estado = PASS para cada campo (nulos = 0)

DECLARE record_col STRING DEFAULT '${v.recordColumnDestino}';
DECLARE query_nulos STRING;

SET query_nulos = (
    WITH campos_record AS (
        SELECT REPLACE(field_path, CONCAT(record_col, '.'), '') as campo
        FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMN_FIELD_PATHS\`
        WHERE table_name = '${v.tablaDestino}'
          AND column_name = record_col
          AND field_path != record_col${bytesFilterDestino}
    )
    SELECT STRING_AGG(
        CONCAT(
            "SELECT '", campo, "' as campo, COUNT(*) as total, ",
            "COUNTIF(r.", campo, " IS NULL) as nulos, ",
            "ROUND(COUNTIF(r.", campo, " IS NULL) * 100.0 / COUNT(*), 2) as pct_nulos, ",
            "CASE WHEN COUNTIF(r.", campo, " IS NULL) = 0 THEN 'PASS' ELSE 'FAIL' END as estado ",
            "FROM \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\` t, UNNEST(t.${v.recordColumnDestino}) r ${filtroR05}"
        ),
        ' UNION ALL '
    )
    FROM campos_record
);

EXECUTE IMMEDIATE query_nulos;`
                });
            }

            // R06 depende del tipo de tabla
            if (currentTableType === 'simple') {
                // R06 AUXILIAR para tabla simple
                queries.push({
                    code: 'R06-AUX',
                    title: 'R06 Auxiliar: Obtener Columnas para Duplicados',
                    description: 'PASO 1: Ejecutar primero para obtener las columnas del destino',
                    isAuxiliary: true,
                    query: `-- R06 AUXILIAR: Obtener columnas para validar duplicados
-- PASO 1: Ejecutar este query y copiar el resultado 'columnas_group'

SELECT 
    STRING_AGG(column_name, ', ') as columnas_group
FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMNS\`
WHERE table_name = '${v.tablaDestino}'
  AND data_type NOT IN ('ARRAY', 'STRUCT', 'RECORD', 'GEOGRAPHY', 'JSON')${bytesFilterDestino};`
                });

                // R06 FINAL para tabla simple
                queries.push({
                    code: 'R06-FINAL',
                    title: 'R06 Final: Sin Duplicados',
                    description: 'PASO 2: Reemplazar <<COLUMNAS>> con el resultado del auxiliar',
                    isAuxiliary: false,
                    query: `-- R06 FINAL: Sin Duplicados - Todos los campos (en DESTINO)
-- PASO 2: Reemplazar <<COLUMNAS>> con 'columnas_group' del query auxiliar
-- Resultado esperado: 0 registros

SELECT 
    <<COLUMNAS>>,
    COUNT(*) as ocurrencias
FROM \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\` d
${v.joinDestino ? v.joinDestino + '\n' : ''}${whereDestino}
GROUP BY <<COLUMNAS>>
HAVING COUNT(*) > 1
ORDER BY ocurrencias DESC
LIMIT 100;`
                });
            } else {
                // R06 AUXILIAR para tabla con RECORD (igual que R07)
                queries.push({
                    code: 'R06-AUX',
                    title: 'R06 Auxiliar: Obtener Campos RECORD para Duplicados',
                    description: 'PASO 1: Ejecutar primero para obtener campos del RECORD',
                    isAuxiliary: true,
                    query: `-- R06 AUXILIAR: Obtener campos del RECORD para validar duplicados
-- PASO 1: Ejecutar este query y copiar el resultado 'columnas_todas'

DECLARE record_col STRING DEFAULT '${v.recordColumnDestino}';

WITH campos_base AS (
    SELECT column_name
    FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMNS\`
    WHERE table_name = '${v.tablaDestino}'
      AND data_type NOT IN ('ARRAY', 'STRUCT', 'RECORD')${bytesFilterDestino}
),
campos_record AS (
    SELECT 
        REPLACE(field_path, CONCAT(record_col, '.'), '') as campo
    FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMN_FIELD_PATHS\`
    WHERE table_name = '${v.tablaDestino}'
      AND column_name = record_col
      AND field_path != record_col${bytesFilterDestino}
)
SELECT 
    CONCAT(
        (SELECT STRING_AGG(CONCAT('t.', column_name), ', ') FROM campos_base),
        ', ',
        (SELECT STRING_AGG(CONCAT('r.', campo), ', ') FROM campos_record)
    ) as columnas_todas;`
                });

                // R06 FINAL para tabla con RECORD
                queries.push({
                    code: 'R06-FINAL',
                    title: 'R06 Final: Sin Duplicados (RECORD)',
                    description: 'PASO 2: Reemplazar <<COLUMNAS>> con columnas_todas del auxiliar',
                    isAuxiliary: false,
                    query: `-- R06 FINAL: Sin Duplicados - Campos RECORD (en DESTINO)
-- PASO 2: Reemplazar <<COLUMNAS>> con 'columnas_todas' del query auxiliar
-- Resultado esperado: 0 registros

SELECT 
    <<COLUMNAS>>,
    COUNT(*) as ocurrencias
FROM \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\` t
LEFT JOIN UNNEST(t.${v.recordColumnDestino}) r
${v.joinDestino ? v.joinDestino + '\n' : ''}${whereDestino}
GROUP BY <<COLUMNAS>>
HAVING COUNT(*) > 1
ORDER BY ocurrencias DESC
LIMIT 100;`
                });
            }

            // R07: Valores coinciden - Query de 2 pasos
            // Filtros sin saltos de línea
            const filtroOrigenR07 = v.filtroOrigen ? v.filtroOrigen.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim() : '';
            const filtroDestinoR07 = v.filtroDestino ? v.filtroDestino.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim() : '';
            
            if (currentTableType === 'simple') {
                // R07 AUXILIAR para tabla simple
                queries.push({
                    code: 'R07-AUX',
                    title: 'R07 Auxiliar: Generar Bloque de Columnas',
                    description: 'PASO 1: Ejecutar primero para obtener el bloque de comparación',
                    isAuxiliary: true,
                    query: `-- R07 AUXILIAR: Generar bloque de columnas para comparar
-- PASO 1: Ejecutar este query y copiar el resultado 'bloque'

WITH ORIGEN AS (
  SELECT column_name
  FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.INFORMATION_SCHEMA.COLUMNS\`
  WHERE table_name = '${v.tablaOrigen}'${bytesFilterOrigen}
), 
DESTINO AS (
  SELECT column_name
  FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMNS\`
  WHERE table_name = '${v.tablaDestino}'${bytesFilterDestino}
)
SELECT 
  STRING_AGG(
    CONCAT(
      'A.', a.column_name, ' AS valor_origen_', a.column_name, ', ',
      'B.', b.column_name, ' AS valor_destino_', b.column_name, ', ',
      "CASE WHEN A.", a.column_name, " IS NULL AND B.", b.column_name, " IS NULL THEN 'IGUAL' ",
      "WHEN UPPER(TRIM(CAST(A.", a.column_name, " AS STRING))) = UPPER(TRIM(CAST(B.", b.column_name, " AS STRING))) THEN 'IGUAL' ",
      "ELSE 'DIFERENTE' END AS estado_", a.column_name
    ),
    ', '
  ) AS bloque 
FROM ORIGEN a  
JOIN DESTINO b ON UPPER(a.column_name) = UPPER(b.column_name);`
                });

                // R07 FINAL para tabla simple
                queries.push({
                    code: 'R07-FINAL',
                    title: 'R07 Final: Valores Coinciden',
                    description: 'PASO 2: Pegar el bloque generado donde indica',
                    isAuxiliary: false,
                    query: `-- R07 FINAL: Valores Coinciden (por PK) - TABLA SIMPLE
-- PASO 2: Pegar el 'bloque' del query auxiliar donde indica
-- Resultado esperado: 0 registros diferentes
-- NOTA: Si desea obtener el total de diferencias, quitar el LIMIT 1000

WITH
  origen AS (
    SELECT * FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.${v.tablaOrigen}\`
    ${filtroOrigenR07 ? 'WHERE ' + filtroOrigenR07 : ''}
  ),
  destino AS (
    SELECT * FROM \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\`
    ${filtroDestinoR07 ? 'WHERE ' + filtroDestinoR07 : ''}
  )
SELECT DISTINCT
    ${pkList.map(pk => `COALESCE(CAST(A.${pk} AS STRING), CAST(B.${pk} AS STRING)) AS ${pk}`).join(',\n    ')},
    -- ═══════════════════════════════════════════════════════════════
    -- PEGAR AQUÍ EL 'bloque' DEL QUERY R07-AUX
    -- Ejemplo:
    -- A.campo1 AS valor_origen_campo1,
    -- B.campo1 AS valor_destino_campo1,
    -- CASE WHEN A.campo1 IS NULL AND B.campo1 IS NULL THEN 'IGUAL' ... END AS estado_campo1,
    -- ═══════════════════════════════════════════════════════════════
FROM origen A
FULL OUTER JOIN destino B
    ON ${pkList.map(pk => `CAST(A.${pk} AS STRING) = CAST(B.${pk} AS STRING)`).join(' AND ')}
ORDER BY 1
LIMIT 1000;`
                });
            } else {
                // R07 AUXILIAR para tabla con RECORD
                queries.push({
                    code: 'R07-AUX',
                    title: 'R07 Auxiliar: Obtener Campos RECORD',
                    description: 'PASO 1: Ejecutar primero para obtener campos del RECORD',
                    isAuxiliary: true,
                    query: `-- R07 AUXILIAR: Obtener campos del RECORD para comparar
-- PASO 1: Ejecutar este query y copiar el resultado 'bloque'

DECLARE record_col_origen STRING DEFAULT '${v.recordColumnOrigen}';
DECLARE record_col_destino STRING DEFAULT '${v.recordColumnDestino}';

WITH ORIGEN AS (
  SELECT field_path 
  FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.INFORMATION_SCHEMA.COLUMN_FIELD_PATHS\`
  WHERE table_name = '${v.tablaOrigen}' 
    AND column_name = record_col_origen
    AND field_path != record_col_origen${bytesFilterOrigen}
), 
DESTINO AS (
  SELECT field_path 
  FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMN_FIELD_PATHS\`
  WHERE table_name = '${v.tablaDestino}'
    AND column_name = record_col_destino
    AND field_path != record_col_destino${bytesFilterDestino}
)
SELECT 
  STRING_AGG(
    CONCAT(
      'oa.', REPLACE(a.field_path, CONCAT(record_col_origen, '.'), ''), 
      ' AS origen_', REPLACE(a.field_path, '.', '_'), ', ',
      'da.', REPLACE(b.field_path, CONCAT(record_col_destino, '.'), ''), 
      ' AS destino_', REPLACE(b.field_path, '.', '_'), ', ',
      "CASE WHEN oa.", REPLACE(a.field_path, CONCAT(record_col_origen, '.'), ''), 
      " IS NULL AND da.", REPLACE(b.field_path, CONCAT(record_col_destino, '.'), ''), 
      " IS NULL THEN 'IGUAL' WHEN CAST(oa.", REPLACE(a.field_path, CONCAT(record_col_origen, '.'), ''), 
      " AS STRING) = CAST(da.", REPLACE(b.field_path, CONCAT(record_col_destino, '.'), ''), 
      " AS STRING) THEN 'IGUAL' ELSE 'DIFERENTE' END AS estado_", 
      REPLACE(a.field_path, '.', '_')
    ),
    ',\\n'
  ) AS bloque 
FROM ORIGEN a  
JOIN DESTINO b ON UPPER(a.field_path) = UPPER(b.field_path);`
                });

                // R07 FINAL para tabla con RECORD
                queries.push({
                    code: 'R07-FINAL',
                    title: 'R07 Final: Valores Coinciden (RECORD)',
                    description: 'PASO 2: Reemplazar <<BLOQUE>> con el resultado del auxiliar',
                    isAuxiliary: false,
                    query: `-- R07 FINAL: Valores Coinciden (RECORD/ARRAY)
-- PASO 2: Reemplazar <<BLOQUE>> con el resultado del query auxiliar
-- Resultado esperado: 0 registros con diferencias
-- NOTA: Si desea obtener el total de diferencias, quitar el LIMIT 1000

WITH
  origen AS (
    SELECT * FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.${v.tablaOrigen}\` o
    ${v.joinOrigen ? v.joinOrigen + '\n    ' : ''}${v.filtroOrigen ? 'WHERE ' + v.filtroOrigen : ''}
  ),
  destino AS (
    SELECT * FROM \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\` d
    ${v.joinDestino ? v.joinDestino + '\n    ' : ''}${v.filtroDestino ? 'WHERE ' + v.filtroDestino : ''}
  )
SELECT DISTINCT
    ${pkList.map(pk => `COALESCE(CAST(o.${pk} AS STRING), CAST(d.${pk} AS STRING)) AS ${pk}`).join(',\n    ')},
    CASE 
        WHEN o.${pkList[0]} IS NULL THEN 'SOLO_DESTINO'
        WHEN d.${pkList[0]} IS NULL THEN 'SOLO_ORIGEN'
        ELSE 'DIFERENTE'
    END as tipo_diferencia,
    <<BLOQUE>>
FROM origen o
LEFT JOIN UNNEST(o.${v.recordColumnOrigen}) oa
FULL OUTER JOIN destino d
    ON ${pkList.map(pk => `CAST(o.${pk} AS STRING) = CAST(d.${pk} AS STRING)`).join(' AND ')}
LEFT JOIN UNNEST(d.${v.recordColumnDestino}) da
ORDER BY 1
LIMIT 1000;`
                });
            }


            // R08: Resumen de Diferencias campo a campo (2 pasos)
            if (currentTableType === 'simple') {
                queries.push({
                    code: 'R08-AUX',
                    title: 'R08 Auxiliar: Generar Bloques de Comparaci\u00f3n',
                    description: 'PASO 1: Ejecutar primero para obtener bloque_diff y bloque_sum',
                    isAuxiliary: true,
                    query: `-- R08 AUXILIAR: Generar bloques para Resumen de Diferencias
-- PASO 1: Ejecutar y copiar 'bloque_diff' y 'bloque_sum'
-- bloque_diff: va dentro del SELECT del CTE joined
-- bloque_sum: va en el SELECT final

WITH ORIGEN AS (
  SELECT column_name
  FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.INFORMATION_SCHEMA.COLUMNS\`
  WHERE table_name = '${v.tablaOrigen}'
    AND data_type NOT IN ('ARRAY', 'STRUCT', 'RECORD')${bytesFilterOrigen}
),
DESTINO AS (
  SELECT column_name
  FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMNS\`
  WHERE table_name = '${v.tablaDestino}'
    AND data_type NOT IN ('ARRAY', 'STRUCT', 'RECORD')${bytesFilterDestino}
)
SELECT
  STRING_AGG(
    CONCAT(
      "CASE WHEN COALESCE(CAST(A.", a.column_name, " AS STRING), '') = COALESCE(CAST(B.", b.column_name, " AS STRING), '') THEN 0 ELSE 1 END AS diff_", a.column_name
    ),
    ',\\n'
  ) AS bloque_diff,
  STRING_AGG(
    CONCAT("SUM(diff_", a.column_name, ") AS dif_", a.column_name),
    ',\\n'
  ) AS bloque_sum
FROM ORIGEN a
JOIN DESTINO b ON UPPER(a.column_name) = UPPER(b.column_name);`
                });

                queries.push({
                    code: 'R08-FINAL',
                    title: 'R08 Final: Resumen de Diferencias',
                    description: 'PASO 2: Pegar bloque_diff y bloque_sum donde indica',
                    isAuxiliary: false,
                    query: `-- R08 FINAL: Resumen de Diferencias campo a campo
-- PASO 2: Pegar 'bloque_diff' y 'bloque_sum' donde indica
-- Resultado esperado: dif_CAMPO = 0 para todos los campos (sin diferencias)

WITH
  origen AS (
    SELECT * FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.${v.tablaOrigen}\`
    ${filtroOrigenR07 ? 'WHERE ' + filtroOrigenR07 : ''}
  ),
  destino AS (
    SELECT * FROM \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\`
    ${filtroDestinoR07 ? 'WHERE ' + filtroDestinoR07 : ''}
  ),
  joined AS (
    SELECT
      ${pkList.map(pk => `COALESCE(CAST(A.${pk} AS STRING), CAST(B.${pk} AS STRING)) AS ${pk}`).join(',\n      ')},
      -- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550
      -- PEGAR AQU\u00cd EL 'bloque_diff' DEL QUERY R08-AUX
      -- Ejemplo:
      -- CASE WHEN COALESCE(CAST(A.campo AS STRING), '') = COALESCE(CAST(B.campo AS STRING), '') THEN 0 ELSE 1 END AS diff_campo,
      -- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550
    FROM origen A
    FULL OUTER JOIN destino B
      ON ${pkList.map(pk => `CAST(A.${pk} AS STRING) = CAST(B.${pk} AS STRING)`).join(' AND ')}
  )
SELECT
  COUNT(1) AS total_registros,
  -- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550
  -- PEGAR AQU\u00cd EL 'bloque_sum' DEL QUERY R08-AUX
  -- Ejemplo:
  -- SUM(diff_campo) AS dif_campo,
  -- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550
FROM joined;`
                });
            } else {
                // R08 para tabla RECORD
                queries.push({
                    code: 'R08-AUX',
                    title: 'R08 Auxiliar: Generar Bloques de Comparaci\u00f3n (RECORD)',
                    description: 'PASO 1: Ejecutar primero para obtener bloque_diff y bloque_sum',
                    isAuxiliary: true,
                    query: `-- R08 AUXILIAR: Generar bloques para Resumen de Diferencias (RECORD)
-- PASO 1: Ejecutar y copiar 'bloque_diff' y 'bloque_sum' (solo campos RECORD + PKs)

DECLARE record_col_origen STRING DEFAULT '${v.recordColumnOrigen}';
DECLARE record_col_destino STRING DEFAULT '${v.recordColumnDestino}';

WITH campos_record_origen AS (
  SELECT REPLACE(field_path, CONCAT(record_col_origen, '.'), '') as campo
  FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.INFORMATION_SCHEMA.COLUMN_FIELD_PATHS\`
  WHERE table_name = '${v.tablaOrigen}' AND column_name = record_col_origen AND field_path != record_col_origen${bytesFilterOrigen}
),
campos_record_destino AS (
  SELECT REPLACE(field_path, CONCAT(record_col_destino, '.'), '') as campo
  FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMN_FIELD_PATHS\`
  WHERE table_name = '${v.tablaDestino}' AND column_name = record_col_destino AND field_path != record_col_destino${bytesFilterDestino}
)
SELECT
  STRING_AGG(
    CONCAT("CASE WHEN COALESCE(CAST(oa.", a.campo, " AS STRING), '') = COALESCE(CAST(da.", b.campo, " AS STRING), '') THEN 0 ELSE 1 END AS diff_", a.campo),
    ',\\n'
  ) AS bloque_diff,
  STRING_AGG(
    CONCAT("SUM(diff_", a.campo, ") AS dif_", a.campo),
    ',\\n'
  ) AS bloque_sum
FROM campos_record_origen a
JOIN campos_record_destino b ON UPPER(a.campo) = UPPER(b.campo);`
                });

                queries.push({
                    code: 'R08-FINAL',
                    title: 'R08 Final: Resumen de Diferencias (RECORD)',
                    description: 'PASO 2: Pegar bloque_diff y bloque_sum donde indica',
                    isAuxiliary: false,
                    query: `-- R08 FINAL: Resumen de Diferencias campo a campo (RECORD)
-- PASO 2: Pegar 'bloque_diff' y 'bloque_sum' donde indica
-- Resultado esperado: dif_CAMPO = 0 para todos (sin diferencias)

WITH
  origen AS (
    SELECT * FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.${v.tablaOrigen}\` o
    ${v.joinOrigen ? v.joinOrigen + '\n    ' : ''}${v.filtroOrigen ? 'WHERE ' + v.filtroOrigen : ''}
  ),
  destino AS (
    SELECT * FROM \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\` d
    ${v.joinDestino ? v.joinDestino + '\n    ' : ''}${v.filtroDestino ? 'WHERE ' + v.filtroDestino : ''}
  ),
  joined AS (
    SELECT
      ${pkList.map(pk => `COALESCE(CAST(A.${pk} AS STRING), CAST(B.${pk} AS STRING)) AS ${pk}`).join(',\n      ')},
      -- PEGAR AQU\u00cd EL 'bloque_diff' (campos base + campos RECORD)
    FROM origen A
    LEFT JOIN UNNEST(A.${v.recordColumnOrigen}) oa
    FULL OUTER JOIN destino B
      ON ${pkList.map(pk => `CAST(A.${pk} AS STRING) = CAST(B.${pk} AS STRING)`).join(' AND ')}
    LEFT JOIN UNNEST(B.${v.recordColumnDestino}) da
  )
SELECT
  COUNT(1) AS total_registros,
  -- PEGAR AQU\u00cd EL 'bloque_sum'
FROM joined;`
                });
            }

            return queries;
        }

        // ========================================================================
        // FUNCIONES PARA TABLA CON DIFERENTE ESTRUCTURA
        // ========================================================================

        function generateUTQueriesDifferent(v) {
            const pkListOrigen = v.pkListOrigen;
            const pkListDestino = v.pkListDestino;
            const camposListOrigen = v.camposListOrigen;
            const camposListDestino = v.camposListDestino;

            const whereOrigen = v.filtroOrigen ? `WHERE ${v.filtroOrigen}` : '';
            const whereDestino = v.filtroDestino ? `WHERE ${v.filtroDestino}` : '';
            const filtroOrigenOneLine = v.filtroOrigen ? v.filtroOrigen.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim() : '';
            const filtroDestinoOneLine = v.filtroDestino ? v.filtroDestino.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim() : '';

            // Filtro data_type para INFORMATION_SCHEMA (controlado por checkboxes "tiene bytes")
            // En claro: excluir BYTES (!=); Encriptado: incluir solo BYTES (=)
            const bytesOpDiff = currentInfoType === 'encrypted' ? "= 'BYTES'" : "!= 'BYTES'";
            const bytesFilterOrigen = v.origenHasBytes ? `\n    AND data_type ${bytesOpDiff}` : '';
            const bytesFilterDestino = v.destinoHasBytes ? `\n    AND data_type ${bytesOpDiff}` : '';

            const queries = [];

            // UT-01: Conteo de registros
            queries.push({
                code: 'UT-01',
                title: 'Conteo de Registros',
                description: 'Valida que la cantidad de registros sea igual entre ORIGEN y DESTINO',
                isAuxiliary: false,
                query: `-- UT-01: Conteo de Registros (ORIGEN vs DESTINO) - DIFERENTE ESTRUCTURA
-- Resultado esperado: diferencia = 0, estado = PASS

WITH conteos AS (
    SELECT 
        (SELECT COUNT(*) FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.${v.tablaOrigen}\` o
         ${v.joinOrigen ? v.joinOrigen + ' ' : ''}${whereOrigen}) as cnt_origen,
        (SELECT COUNT(*) FROM \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\` d
         ${v.joinDestino ? v.joinDestino + ' ' : ''}${whereDestino}) as cnt_destino
)
SELECT 
    cnt_origen as registros_origen,
    cnt_destino as registros_destino,
    cnt_origen - cnt_destino as diferencia,
    CASE 
        WHEN cnt_origen = cnt_destino THEN 'PASS'
        ELSE 'FAIL'
    END as estado
FROM conteos;`
            });

            // UT-01-DIFF1: Registros SOLO en ORIGEN
            queries.push({
                code: 'UT-01-DIFF1',
                title: 'UT-01 Diferencias: Solo en ORIGEN',
                description: 'Muestra registros que existen en ORIGEN pero NO en DESTINO',
                isAuxiliary: true,
                query: `-- UT-01 DIFERENCIAS: Registros SOLO en ORIGEN
-- Muestra los registros que existen en ORIGEN pero NO en DESTINO
-- Usar cuando UT-01 muestra diferencias (estado = FAIL)

SELECT 
    'SOLO_ORIGEN' as ubicacion,
    ${pkListOrigen.map(pk => `o.${pk}`).join(', ')},
    o.*
FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.${v.tablaOrigen}\` o
${v.joinOrigen ? v.joinOrigen + ' ' : ''}
LEFT JOIN \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\` d
    ON ${pkListOrigen.map((pk, i) => `CAST(o.${pk} AS STRING) = CAST(d.${pkListDestino[i]} AS STRING)`).join(' AND ')}
${filtroOrigenOneLine ? 'WHERE ' + filtroOrigenOneLine + ' AND ' : 'WHERE '}d.${pkListDestino[0]} IS NULL
ORDER BY ${pkListOrigen.map(pk => `o.${pk}`).join(', ')}
LIMIT 1000;`
            });

            // UT-01-DIFF2: Registros SOLO en DESTINO
            queries.push({
                code: 'UT-01-DIFF2',
                title: 'UT-01 Diferencias: Solo en DESTINO',
                description: 'Muestra registros que existen en DESTINO pero NO en ORIGEN',
                isAuxiliary: true,
                query: `-- UT-01 DIFERENCIAS: Registros SOLO en DESTINO
-- Muestra los registros que existen en DESTINO pero NO en ORIGEN
-- Usar cuando UT-01 muestra diferencias (estado = FAIL)

SELECT 
    'SOLO_DESTINO' as ubicacion,
    ${pkListDestino.map(pk => `d.${pk}`).join(', ')},
    d.*
FROM \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\` d
${v.joinDestino ? v.joinDestino + ' ' : ''}
LEFT JOIN \`${v.proyectoOrigen}.${v.datasetOrigen}.${v.tablaOrigen}\` o
    ON ${pkListDestino.map((pk, i) => `CAST(d.${pk} AS STRING) = CAST(o.${pkListOrigen[i]} AS STRING)`).join(' AND ')}
${filtroDestinoOneLine ? 'WHERE ' + filtroDestinoOneLine + ' AND ' : 'WHERE '}o.${pkListOrigen[0]} IS NULL
ORDER BY ${pkListDestino.map(pk => `d.${pk}`).join(', ')}
LIMIT 1000;`
            });

            // UT-02: Duplicados - Auxiliar
            queries.push({
                code: 'UT-02-AUX',
                title: 'UT-02 Auxiliar: Obtener Columnas para Duplicados',
                description: 'PASO 1: Ejecutar primero para obtener las columnas del destino',
                isAuxiliary: true,
                query: `-- UT-02 AUXILIAR: Obtener columnas para validar duplicados (DESTINO)
-- PASO 1: Ejecutar este query y copiar el resultado 'columnas_group'

SELECT 
    STRING_AGG(column_name, ', ') as columnas_group
FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMNS\`
WHERE table_name = '${v.tablaDestino}'
  AND data_type NOT IN ('ARRAY', 'STRUCT', 'RECORD', 'GEOGRAPHY', 'JSON')${bytesFilterDestino};`
            });

            // UT-02: Duplicados - Final
            queries.push({
                code: 'UT-02-FINAL',
                title: 'UT-02 Final: Valores Únicos (Todos los Campos)',
                description: 'PASO 2: Reemplazar <<COLUMNAS>> con el resultado del query auxiliar',
                isAuxiliary: false,
                query: `-- UT-02 FINAL: Valores Únicos - Duplicados en TODOS los campos
-- PASO 2: Reemplazar <<COLUMNAS>> con 'columnas_group' del query auxiliar
-- Resultado esperado: 0 registros (sin duplicados)

SELECT 
    <<COLUMNAS>>,
    COUNT(*) as ocurrencias
FROM \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\` d
${v.joinDestino ? v.joinDestino + '\n' : ''}${whereDestino}
GROUP BY <<COLUMNAS>>
HAVING COUNT(*) > 1
ORDER BY ocurrencias DESC
LIMIT 100;`
            });

            // UT-03: Integridad Bidireccional con mapeo
            // Generar el JOIN condition con campos mapeados
            const pkJoinConditions = pkListOrigen.map((pkO, i) => 
                `CAST(A.${pkO} AS STRING) = CAST(B.${pkListDestino[i]} AS STRING)`
            ).join(' AND ');

            // Generar SELECT de PKs con COALESCE
            const pkSelectList = pkListOrigen.map((pkO, i) => 
                `COALESCE(CAST(A.${pkO} AS STRING), CAST(B.${pkListDestino[i]} AS STRING)) AS ${pkO}`
            ).join(',\n    ');

            if (camposListOrigen.length > 0 && camposListDestino.length > 0) {
                // Si hay campos mapeados manualmente, generar query directo
                const camposCompare = camposListOrigen.map((cO, i) => {
                    const cD = camposListDestino[i];
                    return `A.${cO} AS origen_${cO}, B.${cD} AS destino_${cD}, 
    CASE WHEN A.${cO} IS NULL AND B.${cD} IS NULL THEN 'IGUAL' 
         WHEN UPPER(TRIM(CAST(A.${cO} AS STRING))) = UPPER(TRIM(CAST(B.${cD} AS STRING))) THEN 'IGUAL' 
         ELSE 'DIFERENTE' END AS estado_${cO}`;
                }).join(',\n    ');

                queries.push({
                    code: 'UT-03',
                    title: 'Integridad Bidireccional (Mapeo Manual)',
                    description: 'Compara valores usando el mapeo de campos definido',
                    isAuxiliary: false,
                    query: `-- UT-03: Integridad Bidireccional (FULL OUTER JOIN) - MAPEO MANUAL
-- PKs: ${pkListOrigen.join(', ')} → ${pkListDestino.join(', ')}
-- Campos: ${camposListOrigen.join(', ')} → ${camposListDestino.join(', ')}
-- Resultado esperado: 0 registros con diferencias
-- NOTA: Si desea obtener el total de diferencias, quitar el LIMIT 1000

WITH
  origen AS (
    SELECT * FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.${v.tablaOrigen}\` o
    ${v.joinOrigen ? v.joinOrigen + '\n    ' : ''}${filtroOrigenOneLine ? 'WHERE ' + filtroOrigenOneLine : ''}
  ),
  destino AS (
    SELECT * FROM \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\` d
    ${v.joinDestino ? v.joinDestino + '\n    ' : ''}${filtroDestinoOneLine ? 'WHERE ' + filtroDestinoOneLine : ''}
  )
SELECT DISTINCT
    ${pkSelectList},
    CASE 
        WHEN A.${pkListOrigen[0]} IS NULL THEN 'SOLO_DESTINO'
        WHEN B.${pkListDestino[0]} IS NULL THEN 'SOLO_ORIGEN'
        ELSE 'AMBOS'
    END as presencia,
    ${camposCompare}
FROM origen A
FULL OUTER JOIN destino B
    ON ${pkJoinConditions}
ORDER BY 1
LIMIT 1000;`
                });
            } else {
                // Si no hay campos mapeados, generar queries ejecutables
                // AUX1: Genera bloque para columnas con MISMO nombre (copiar directo)
                queries.push({
                    code: 'UT-03-AUX1',
                    title: 'UT-03 Auxiliar 1: Bloque para Columnas con Mismo Nombre',
                    description: 'PASO 1: Ejecutar y copiar resultado "bloque" (columnas con mismo nombre)',
                    isAuxiliary: true,
                    query: `-- UT-03 AUXILIAR 1: Generar bloque para columnas con MISMO nombre
-- PASO 1: Ejecutar este query y copiar el resultado 'bloque'
-- Este bloque cubre columnas que se llaman IGUAL en ambas tablas

WITH ORIGEN AS (
  SELECT column_name
  FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.INFORMATION_SCHEMA.COLUMNS\`
  WHERE table_name = '${v.tablaOrigen}'
    AND column_name NOT IN (${pkListOrigen.map(p => `'${p}'`).join(', ')})
    AND data_type NOT IN ('ARRAY', 'STRUCT', 'RECORD')
), 
DESTINO AS (
  SELECT column_name
  FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMNS\`
  WHERE table_name = '${v.tablaDestino}'
    AND column_name NOT IN (${pkListDestino.map(p => `'${p}'`).join(', ')})
    AND data_type NOT IN ('ARRAY', 'STRUCT', 'RECORD')
)
SELECT 
  STRING_AGG(
    CONCAT(
      'A.', a.column_name, ' AS origen_', a.column_name, ', ',
      'B.', b.column_name, ' AS destino_', b.column_name, ', ',
      "CASE WHEN A.", a.column_name, " IS NULL AND B.", b.column_name, " IS NULL THEN 'IGUAL' ",
      "WHEN UPPER(TRIM(CAST(A.", a.column_name, " AS STRING))) = UPPER(TRIM(CAST(B.", b.column_name, " AS STRING))) THEN 'IGUAL' ",
      "ELSE 'DIFERENTE' END AS estado_", a.column_name
    ),
    ',\\n'
  ) AS bloque 
FROM ORIGEN a  
JOIN DESTINO b ON UPPER(a.column_name) = UPPER(b.column_name);`
                });

                // AUX2: Lista columnas con diferente nombre y muestra matches por similitud + sinónimos
                queries.push({
                    code: 'UT-03-AUX2',
                    title: 'UT-03 Auxiliar 2: Matches por Similitud + Sinónimos',
                    description: 'PASO 2: Ver matches automáticos y columnas sin match',
                    isAuxiliary: true,
                    query: `-- UT-03 AUXILIAR 2: Matches por similitud + sinónimos y columnas sin match
-- PASO 2: Verificar matches automáticos y columnas pendientes de mapear
-- Sinónimos: nro=numero, cod=codigo, fec=fecha, desc=descripcion, etc.

-- Función para normalizar sinónimos
CREATE TEMP FUNCTION normalizar_sinonimo(palabra STRING) AS (
  CASE LOWER(palabra)
    WHEN 'nro' THEN 'numero' WHEN 'num' THEN 'numero' WHEN 'nr' THEN 'numero'
    WHEN 'cod' THEN 'codigo' WHEN 'cd' THEN 'codigo'
    WHEN 'id' THEN 'identificador' WHEN 'ident' THEN 'identificador'
    WHEN 'fec' THEN 'fecha' WHEN 'fch' THEN 'fecha' WHEN 'dt' THEN 'fecha' WHEN 'date' THEN 'fecha'
    WHEN 'desc' THEN 'descripcion' WHEN 'dsc' THEN 'descripcion'
    WHEN 'cant' THEN 'cantidad' WHEN 'qty' THEN 'cantidad'
    WHEN 'obs' THEN 'observacion'
    WHEN 'dir' THEN 'direccion'
    WHEN 'tel' THEN 'telefono' WHEN 'fon' THEN 'telefono'
    WHEN 'nom' THEN 'nombre' WHEN 'name' THEN 'nombre'
    WHEN 'tip' THEN 'tipo' WHEN 'type' THEN 'tipo'
    WHEN 'est' THEN 'estado' WHEN 'status' THEN 'estado'
    WHEN 'mto' THEN 'monto' WHEN 'mnt' THEN 'monto' WHEN 'amount' THEN 'monto'
    ELSE LOWER(palabra)
  END
);

WITH 
origen_sin_match AS (
  SELECT o.column_name,
    (SELECT STRING_AGG(normalizar_sinonimo(word), '_' ORDER BY normalizar_sinonimo(word)) 
     FROM UNNEST(SPLIT(LOWER(o.column_name), '_')) as word WHERE word != '') as palabras_norm
  FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.INFORMATION_SCHEMA.COLUMNS\` o
  WHERE o.table_name = '${v.tablaOrigen}'
    AND o.column_name NOT IN (${pkListOrigen.map(p => `'${p}'`).join(', ')})
    AND o.data_type NOT IN ('ARRAY', 'STRUCT', 'RECORD')
    AND NOT EXISTS (
      SELECT 1 FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMNS\` d
      WHERE d.table_name = '${v.tablaDestino}' AND UPPER(d.column_name) = UPPER(o.column_name)
    )
),
destino_sin_match AS (
  SELECT d.column_name,
    (SELECT STRING_AGG(normalizar_sinonimo(word), '_' ORDER BY normalizar_sinonimo(word)) 
     FROM UNNEST(SPLIT(LOWER(d.column_name), '_')) as word WHERE word != '') as palabras_norm
  FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMNS\` d
  WHERE d.table_name = '${v.tablaDestino}'
    AND d.column_name NOT IN (${pkListDestino.map(p => `'${p}'`).join(', ')})
    AND d.data_type NOT IN ('ARRAY', 'STRUCT', 'RECORD')
    AND NOT EXISTS (
      SELECT 1 FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.INFORMATION_SCHEMA.COLUMNS\` o
      WHERE o.table_name = '${v.tablaOrigen}' AND UPPER(o.column_name) = UPPER(d.column_name)
    )
)

-- Matches encontrados por similitud + sinónimos (se generarán en AUX3)
SELECT '✅ MATCH' as estado, o.column_name as col_origen, d.column_name as col_destino, 
       o.palabras_norm as match_por,
       'AUX3 generará el bloque' as accion
FROM origen_sin_match o
JOIN destino_sin_match d ON o.palabras_norm = d.palabras_norm

UNION ALL

-- Columnas de ORIGEN sin match (requieren mapeo manual)
SELECT '❌ SIN MATCH' as estado, o.column_name as col_origen, NULL as col_destino,
       o.palabras_norm as match_por,
       'Usar AUX4 (mapeo manual)' as accion
FROM origen_sin_match o
WHERE NOT EXISTS (
  SELECT 1 FROM destino_sin_match d WHERE o.palabras_norm = d.palabras_norm
)

UNION ALL

-- Columnas de DESTINO sin match (requieren mapeo manual)
SELECT '❌ SIN MATCH' as estado, NULL as col_origen, d.column_name as col_destino,
       d.palabras_norm as match_por,
       'Usar AUX4 (mapeo manual)' as accion
FROM destino_sin_match d
WHERE NOT EXISTS (
  SELECT 1 FROM origen_sin_match o WHERE o.palabras_norm = d.palabras_norm
)

ORDER BY estado DESC, col_origen, col_destino;`
                });

                // AUX3: Generar bloque automático para campos con diferente nombre (por similitud + sinónimos)
                queries.push({
                    code: 'UT-03-AUX3',
                    title: 'UT-03 Auxiliar 3: Bloque para Campos con Diferente Nombre',
                    description: 'PASO 3: Ejecutar y copiar resultado "bloque" (match por similitud + sinónimos)',
                    isAuxiliary: true,
                    query: `-- UT-03 AUXILIAR 3: Generar bloque para campos con DIFERENTE nombre
-- PASO 3: Ejecutar este query y copiar el resultado 'bloque'
-- Usa similitud de palabras + sinónimos: plan_nro ↔ NUMERO_PLAN, moneda_id ↔ id_moneda

-- Función para normalizar sinónimos
CREATE TEMP FUNCTION normalizar_sinonimo(palabra STRING) AS (
  CASE LOWER(palabra)
    -- Números
    WHEN 'nro' THEN 'numero'
    WHEN 'num' THEN 'numero'
    WHEN 'nr' THEN 'numero'
    -- Códigos
    WHEN 'cod' THEN 'codigo'
    WHEN 'cd' THEN 'codigo'
    -- Identificadores
    WHEN 'id' THEN 'identificador'
    WHEN 'ident' THEN 'identificador'
    -- Fechas
    WHEN 'fec' THEN 'fecha'
    WHEN 'fch' THEN 'fecha'
    WHEN 'dt' THEN 'fecha'
    WHEN 'date' THEN 'fecha'
    -- Descripciones
    WHEN 'desc' THEN 'descripcion'
    WHEN 'dsc' THEN 'descripcion'
    -- Cantidades
    WHEN 'cant' THEN 'cantidad'
    WHEN 'qty' THEN 'cantidad'
    -- Observaciones
    WHEN 'obs' THEN 'observacion'
    -- Direcciones
    WHEN 'dir' THEN 'direccion'
    -- Teléfonos
    WHEN 'tel' THEN 'telefono'
    WHEN 'fon' THEN 'telefono'
    -- Nombres
    WHEN 'nom' THEN 'nombre'
    WHEN 'name' THEN 'nombre'
    -- Tipos
    WHEN 'tip' THEN 'tipo'
    WHEN 'type' THEN 'tipo'
    -- Estados
    WHEN 'est' THEN 'estado'
    WHEN 'status' THEN 'estado'
    -- Montos
    WHEN 'mto' THEN 'monto'
    WHEN 'mnt' THEN 'monto'
    WHEN 'amount' THEN 'monto'
    ELSE LOWER(palabra)
  END
);

WITH 
-- Columnas de ORIGEN sin match exacto
origen_sin_match AS (
  SELECT o.column_name,
    -- Normalizar: aplicar sinónimos y ordenar palabras
    (SELECT STRING_AGG(normalizar_sinonimo(word), '_' ORDER BY normalizar_sinonimo(word)) 
     FROM UNNEST(SPLIT(LOWER(o.column_name), '_')) as word
     WHERE word != '') as palabras_norm
  FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.INFORMATION_SCHEMA.COLUMNS\` o
  WHERE o.table_name = '${v.tablaOrigen}'
    AND o.column_name NOT IN (${pkListOrigen.map(p => `'${p}'`).join(', ')})
    AND o.data_type NOT IN ('ARRAY', 'STRUCT', 'RECORD')
    AND NOT EXISTS (
      SELECT 1 FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMNS\` d
      WHERE d.table_name = '${v.tablaDestino}' AND UPPER(d.column_name) = UPPER(o.column_name)
    )
),
-- Columnas de DESTINO sin match exacto
destino_sin_match AS (
  SELECT d.column_name,
    -- Normalizar: aplicar sinónimos y ordenar palabras
    (SELECT STRING_AGG(normalizar_sinonimo(word), '_' ORDER BY normalizar_sinonimo(word)) 
     FROM UNNEST(SPLIT(LOWER(d.column_name), '_')) as word
     WHERE word != '') as palabras_norm
  FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMNS\` d
  WHERE d.table_name = '${v.tablaDestino}'
    AND d.column_name NOT IN (${pkListDestino.map(p => `'${p}'`).join(', ')})
    AND d.data_type NOT IN ('ARRAY', 'STRUCT', 'RECORD')
    AND NOT EXISTS (
      SELECT 1 FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.INFORMATION_SCHEMA.COLUMNS\` o
      WHERE o.table_name = '${v.tablaOrigen}' AND UPPER(o.column_name) = UPPER(d.column_name)
    )
),
-- Match por similitud de palabras (con sinónimos)
matches AS (
  SELECT 
    o.column_name as col_origen,
    d.column_name as col_destino
  FROM origen_sin_match o
  JOIN destino_sin_match d ON o.palabras_norm = d.palabras_norm
)
SELECT 
  CASE 
    WHEN COUNT(*) = 0 THEN '-- No se encontraron matches por similitud'
    ELSE STRING_AGG(
      CONCAT(
        'A.', col_origen, ' AS origen_', col_origen, ', ',
        'B.', col_destino, ' AS destino_', col_destino, ', ',
        "CASE WHEN A.", col_origen, " IS NULL AND B.", col_destino, " IS NULL THEN 'IGUAL' ",
        "WHEN UPPER(TRIM(CAST(A.", col_origen, " AS STRING))) = UPPER(TRIM(CAST(B.", col_destino, " AS STRING))) THEN 'IGUAL' ",
        "ELSE 'DIFERENTE' END AS estado_", col_origen
      ),
      ',\\n'
    )
  END AS bloque
FROM matches;`
                });

                // AUX4: Plantilla manual para campos sin match automático
                queries.push({
                    code: 'UT-03-AUX4',
                    title: 'UT-03 Auxiliar 4: Plantilla Manual (campos sin match)',
                    description: 'PASO 4: Solo si AUX2 muestra columnas ❌ SIN MATCH',
                    isAuxiliary: true,
                    query: `-- UT-03 AUXILIAR 4: Plantilla para campos que NO hicieron match automático
-- PASO 4: Solo usar si AUX2 muestra columnas con ❌ SIN MATCH
-- Copiar y reemplazar <<CAMPO_ORIGEN>> y <<CAMPO_DESTINO>> según corresponda

-- ═══════════════════════════════════════════════════════════════
-- PLANTILLA (copiar por cada par de campos sin match automático):
-- ═══════════════════════════════════════════════════════════════

A.<<CAMPO_ORIGEN>> AS origen_<<CAMPO_ORIGEN>>, 
B.<<CAMPO_DESTINO>> AS destino_<<CAMPO_DESTINO>>, 
CASE 
    WHEN A.<<CAMPO_ORIGEN>> IS NULL AND B.<<CAMPO_DESTINO>> IS NULL THEN 'IGUAL' 
    WHEN UPPER(TRIM(CAST(A.<<CAMPO_ORIGEN>> AS STRING))) = UPPER(TRIM(CAST(B.<<CAMPO_DESTINO>> AS STRING))) THEN 'IGUAL' 
    ELSE 'DIFERENTE' 
END AS estado_<<CAMPO_ORIGEN>>,

-- ═══════════════════════════════════════════════════════════════
-- EJEMPLO: Si nombre_completo (origen) → full_name (destino)
-- ═══════════════════════════════════════════════════════════════

A.nombre_completo AS origen_nombre_completo, 
B.full_name AS destino_full_name, 
CASE 
    WHEN A.nombre_completo IS NULL AND B.full_name IS NULL THEN 'IGUAL' 
    WHEN UPPER(TRIM(CAST(A.nombre_completo AS STRING))) = UPPER(TRIM(CAST(B.full_name AS STRING))) THEN 'IGUAL' 
    ELSE 'DIFERENTE' 
END AS estado_nombre_completo,`
                });

                queries.push({
                    code: 'UT-03-FINAL',
                    title: 'UT-03 Final: Integridad Bidireccional',
                    description: 'PASO 5: Pegar bloques de AUX1 + AUX3 + AUX4 (si aplica)',
                    isAuxiliary: false,
                    query: `-- UT-03 FINAL: Integridad Bidireccional (FULL OUTER JOIN) - DIFERENTE ESTRUCTURA
-- PKs ORIGEN: ${pkListOrigen.join(', ')}
-- PKs DESTINO: ${pkListDestino.join(', ')}
-- 
-- INSTRUCCIONES:
--   1. Pegar el 'bloque' del AUX1 (columnas con MISMO nombre)
--   2. Pegar el 'bloque' del AUX3 (columnas con DIFERENTE nombre - match automático)
--   3. Si AUX2 mostró columnas ❌ SIN MATCH, agregar del AUX4 (mapeo manual)
--
-- Resultado esperado: 0 registros con diferencias
-- NOTA: Si desea obtener el total de diferencias, quitar el LIMIT 1000

WITH
  origen AS (
    SELECT * FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.${v.tablaOrigen}\` o
    ${v.joinOrigen ? v.joinOrigen + '\n    ' : ''}${filtroOrigenOneLine ? 'WHERE ' + filtroOrigenOneLine : ''}
  ),
  destino AS (
    SELECT * FROM \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\` d
    ${v.joinDestino ? v.joinDestino + '\n    ' : ''}${filtroDestinoOneLine ? 'WHERE ' + filtroDestinoOneLine : ''}
  )
SELECT DISTINCT
    ${pkSelectList},
    CASE 
        WHEN A.${pkListOrigen[0]} IS NULL THEN 'SOLO_DESTINO'
        WHEN B.${pkListDestino[0]} IS NULL THEN 'SOLO_ORIGEN'
        ELSE 'AMBOS'
    END as presencia,
    -- ═══════════════════════════════════════════════════════════════
    -- [AUX1] PEGAR AQUÍ: Columnas con MISMO nombre
    -- ═══════════════════════════════════════════════════════════════
    
    -- ═══════════════════════════════════════════════════════════════
    -- [AUX3] PEGAR AQUÍ: Columnas con DIFERENTE nombre (match automático)
    -- ═══════════════════════════════════════════════════════════════
    
    -- ═══════════════════════════════════════════════════════════════
    -- [AUX4] PEGAR AQUÍ: Columnas sin match automático (mapeo manual)
    -- (Solo si AUX2 mostró columnas con ❌ SIN MATCH)
    -- ═══════════════════════════════════════════════════════════════
FROM origen A
FULL OUTER JOIN destino B
    ON ${pkJoinConditions}
ORDER BY 1
LIMIT 1000;`
                });
            }


            // UT-04: Resumen de Diferencias campo a campo (2 pasos)
            if (currentTableType === 'simple') {
                queries.push({
                    code: 'UT-04-AUX',
                    title: 'UT-04 Auxiliar: Generar Bloques de Comparaci\u00f3n',
                    description: 'PASO 1: Ejecutar primero para obtener bloque_diff y bloque_sum',
                    isAuxiliary: true,
                    query: `-- UT-04 AUXILIAR: Generar bloques para Resumen de Diferencias
-- PASO 1: Ejecutar y copiar 'bloque_diff' y 'bloque_sum'
-- bloque_diff: va dentro del SELECT del CTE joined
-- bloque_sum: va en el SELECT final

WITH ORIGEN AS (
  SELECT column_name
  FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.INFORMATION_SCHEMA.COLUMNS\`
  WHERE table_name = '${v.tablaOrigen}'
    AND data_type NOT IN ('ARRAY', 'STRUCT', 'RECORD')${bytesFilterOrigen}
),
DESTINO AS (
  SELECT column_name
  FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMNS\`
  WHERE table_name = '${v.tablaDestino}'
    AND data_type NOT IN ('ARRAY', 'STRUCT', 'RECORD')${bytesFilterDestino}
)
SELECT
  STRING_AGG(
    CONCAT(
      "CASE WHEN COALESCE(CAST(A.", a.column_name, " AS STRING), '') = COALESCE(CAST(B.", b.column_name, " AS STRING), '') THEN 0 ELSE 1 END AS diff_", a.column_name
    ),
    ',\\n'
  ) AS bloque_diff,
  STRING_AGG(
    CONCAT("SUM(diff_", a.column_name, ") AS dif_", a.column_name),
    ',\\n'
  ) AS bloque_sum
FROM ORIGEN a
JOIN DESTINO b ON UPPER(a.column_name) = UPPER(b.column_name);`
                });

                queries.push({
                    code: 'UT-04-FINAL',
                    title: 'UT-04 Final: Resumen de Diferencias',
                    description: 'PASO 2: Pegar bloque_diff y bloque_sum donde indica',
                    isAuxiliary: false,
                    query: `-- UT-04 FINAL: Resumen de Diferencias campo a campo
-- PASO 2: Pegar 'bloque_diff' y 'bloque_sum' donde indica
-- Resultado esperado: dif_CAMPO = 0 para todos los campos (sin diferencias)

WITH
  origen AS (
    SELECT * FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.${v.tablaOrigen}\` o
    ${v.joinOrigen ? v.joinOrigen + '\n    ' : ''}${filtroOrigenOneLine ? 'WHERE ' + filtroOrigenOneLine : ''}
  ),
  destino AS (
    SELECT * FROM \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\` d
    ${v.joinDestino ? v.joinDestino + '\n    ' : ''}${filtroDestinoOneLine ? 'WHERE ' + filtroDestinoOneLine : ''}
  ),
  joined AS (
    SELECT
      ${pkList.map(pk => `COALESCE(CAST(A.${pk} AS STRING), CAST(B.${pk} AS STRING)) AS ${pk}`).join(',\n      ')},
      -- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550
      -- PEGAR AQU\u00cd EL 'bloque_diff' DEL QUERY UT-04-AUX
      -- Ejemplo:
      -- CASE WHEN COALESCE(CAST(A.campo AS STRING), '') = COALESCE(CAST(B.campo AS STRING), '') THEN 0 ELSE 1 END AS diff_campo,
      -- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550
    FROM origen A
    FULL OUTER JOIN destino B
      ON ${pkList.map(pk => `CAST(A.${pk} AS STRING) = CAST(B.${pk} AS STRING)`).join(' AND ')}
  )
SELECT
  COUNT(1) AS total_registros,
  -- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550
  -- PEGAR AQU\u00cd EL 'bloque_sum' DEL QUERY UT-04-AUX
  -- Ejemplo:
  -- SUM(diff_campo) AS dif_campo,
  -- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550
FROM joined;`
                });
            } else if (currentTableType === 'record') {
                // UT-04 para tabla RECORD
                queries.push({
                    code: 'UT-04-AUX',
                    title: 'UT-04 Auxiliar: Generar Bloques de Comparaci\u00f3n (RECORD)',
                    description: 'PASO 1: Ejecutar primero para obtener bloque_diff y bloque_sum',
                    isAuxiliary: true,
                    query: `-- UT-04 AUXILIAR: Generar bloques para Resumen de Diferencias (RECORD)
-- PASO 1: Ejecutar y copiar 'bloque_diff' y 'bloque_sum' (solo campos RECORD + PKs)

DECLARE record_col_origen STRING DEFAULT '${v.recordColumnOrigen}';
DECLARE record_col_destino STRING DEFAULT '${v.recordColumnDestino}';

WITH campos_record_origen AS (
  SELECT REPLACE(field_path, CONCAT(record_col_origen, '.'), '') as campo
  FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.INFORMATION_SCHEMA.COLUMN_FIELD_PATHS\`
  WHERE table_name = '${v.tablaOrigen}' AND column_name = record_col_origen AND field_path != record_col_origen${bytesFilterOrigen}
),
campos_record_destino AS (
  SELECT REPLACE(field_path, CONCAT(record_col_destino, '.'), '') as campo
  FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMN_FIELD_PATHS\`
  WHERE table_name = '${v.tablaDestino}' AND column_name = record_col_destino AND field_path != record_col_destino${bytesFilterDestino}
)
SELECT
  STRING_AGG(
    CONCAT("CASE WHEN COALESCE(CAST(oa.", a.campo, " AS STRING), '') = COALESCE(CAST(da.", b.campo, " AS STRING), '') THEN 0 ELSE 1 END AS diff_", a.campo),
    ',\\n'
  ) AS bloque_diff,
  STRING_AGG(
    CONCAT("SUM(diff_", a.campo, ") AS dif_", a.campo),
    ',\\n'
  ) AS bloque_sum
FROM campos_record_origen a
JOIN campos_record_destino b ON UPPER(a.campo) = UPPER(b.campo);`
                });

                queries.push({
                    code: 'UT-04-FINAL',
                    title: 'UT-04 Final: Resumen de Diferencias (RECORD)',
                    description: 'PASO 2: Pegar bloque_diff y bloque_sum donde indica',
                    isAuxiliary: false,
                    query: `-- UT-04 FINAL: Resumen de Diferencias campo a campo (RECORD)
-- PASO 2: Pegar 'bloque_diff' y 'bloque_sum' donde indica
-- Resultado esperado: dif_CAMPO = 0 para todos (sin diferencias)

WITH
  origen AS (
    SELECT * FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.${v.tablaOrigen}\` o
    ${v.joinOrigen ? v.joinOrigen + '\n    ' : ''}${v.filtroOrigen ? 'WHERE ' + v.filtroOrigen : ''}
  ),
  destino AS (
    SELECT * FROM \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\` d
    ${v.joinDestino ? v.joinDestino + '\n    ' : ''}${v.filtroDestino ? 'WHERE ' + v.filtroDestino : ''}
  ),
  joined AS (
    SELECT
      ${pkList.map(pk => `COALESCE(CAST(A.${pk} AS STRING), CAST(B.${pk} AS STRING)) AS ${pk}`).join(',\n      ')},
      -- PEGAR AQU\u00cd EL 'bloque_diff' (campos base + campos RECORD)
    FROM origen A
    LEFT JOIN UNNEST(A.${v.recordColumnOrigen}) oa
    FULL OUTER JOIN destino B
      ON ${pkList.map(pk => `CAST(A.${pk} AS STRING) = CAST(B.${pk} AS STRING)`).join(' AND ')}
    LEFT JOIN UNNEST(B.${v.recordColumnDestino}) da
  )
SELECT
  COUNT(1) AS total_registros,
  -- PEGAR AQU\u00cd EL 'bloque_sum'
FROM joined;`
                });
            }


            // UT-04: Resumen de Diferencias campo a campo (Diferente Estructura)
            const ut04PkJoin = pkListOrigen.map((pkO, i) => 
                `CAST(A.${pkO} AS STRING) = CAST(B.${pkListDestino[i]} AS STRING)`
            ).join(' AND ');
            const ut04PkSelect = pkListOrigen.map((pkO, i) => 
                `COALESCE(CAST(A.${pkO} AS STRING), CAST(B.${pkListDestino[i]} AS STRING)) AS ${pkO}`
            ).join(',\n      ');

            if (camposListOrigen.length > 0 && camposListDestino.length > 0) {
                // Con mapeo manual
                const diffBlocks = camposListOrigen.map((cO, i) => {
                    const cD = camposListDestino[i];
                    return `CASE WHEN COALESCE(CAST(A.${cO} AS STRING), '') = COALESCE(CAST(B.${cD} AS STRING), '') THEN 0 ELSE 1 END AS diff_${cO}`;
                }).join(',\n      ');

                const sumBlocks = camposListOrigen.map(cO => 
                    `SUM(diff_${cO}) AS dif_${cO}`
                ).join(',\n  ');

                queries.push({
                    code: 'UT-04',
                    title: 'Resumen de Diferencias (Mapeo Manual)',
                    description: 'Resumen campo a campo de diferencias entre origen y destino',
                    isAuxiliary: false,
                    query: `-- UT-04: Resumen de Diferencias campo a campo - MAPEO MANUAL
-- PKs: ${pkListOrigen.join(', ')} \u2192 ${pkListDestino.join(', ')}
-- Resultado esperado: dif_CAMPO = 0 para todos (sin diferencias)

WITH
  origen AS (
    SELECT * FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.${v.tablaOrigen}\` o
    ${v.joinOrigen ? v.joinOrigen + '\n    ' : ''}${filtroOrigenOneLine ? 'WHERE ' + filtroOrigenOneLine : ''}
  ),
  destino AS (
    SELECT * FROM \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\` d
    ${v.joinDestino ? v.joinDestino + '\n    ' : ''}${filtroDestinoOneLine ? 'WHERE ' + filtroDestinoOneLine : ''}
  ),
  joined AS (
    SELECT
      ${ut04PkSelect},
      ${diffBlocks}
    FROM origen A
    FULL OUTER JOIN destino B
      ON ${ut04PkJoin}
  )
SELECT
  COUNT(1) AS total_registros,
  ${sumBlocks}
FROM joined;`
                });
            } else {
                // Sin mapeo manual - usar AUX
                queries.push({
                    code: 'UT-04-AUX',
                    title: 'UT-04 Auxiliar: Generar Bloques de Comparaci\u00f3n',
                    description: 'PASO 1: Ejecutar y copiar bloque_diff y bloque_sum',
                    isAuxiliary: true,
                    query: `-- UT-04 AUXILIAR: Generar bloques para Resumen de Diferencias (Diferente Estructura)
-- PASO 1: Ejecutar y copiar 'bloque_diff' y 'bloque_sum'
-- Incluye: columnas con mismo nombre + matches por sin\u00f3nimos

CREATE TEMP FUNCTION normalizar_sinonimo(palabra STRING) AS (
  CASE LOWER(palabra)
    WHEN 'nro' THEN 'numero' WHEN 'num' THEN 'numero' WHEN 'nr' THEN 'numero'
    WHEN 'cod' THEN 'codigo' WHEN 'cd' THEN 'codigo'
    WHEN 'id' THEN 'identificador' WHEN 'ident' THEN 'identificador'
    WHEN 'fec' THEN 'fecha' WHEN 'fch' THEN 'fecha' WHEN 'dt' THEN 'fecha'
    WHEN 'desc' THEN 'descripcion' WHEN 'dsc' THEN 'descripcion'
    WHEN 'nom' THEN 'nombre' WHEN 'name' THEN 'nombre'
    WHEN 'tip' THEN 'tipo' WHEN 'type' THEN 'tipo'
    WHEN 'est' THEN 'estado' WHEN 'status' THEN 'estado'
    WHEN 'mto' THEN 'monto' WHEN 'mnt' THEN 'monto' WHEN 'amount' THEN 'monto'
    ELSE LOWER(palabra)
  END
);

WITH 
cols_origen AS (
  SELECT column_name,
    (SELECT STRING_AGG(normalizar_sinonimo(w), '_' ORDER BY normalizar_sinonimo(w)) FROM UNNEST(SPLIT(LOWER(column_name), '_')) w WHERE w != '') as norm
  FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.INFORMATION_SCHEMA.COLUMNS\`
  WHERE table_name = '${v.tablaOrigen}' AND column_name NOT IN (${pkListOrigen.map(p => `'${p}'`).join(', ')}) AND data_type NOT IN ('ARRAY','STRUCT','RECORD')
),
cols_destino AS (
  SELECT column_name,
    (SELECT STRING_AGG(normalizar_sinonimo(w), '_' ORDER BY normalizar_sinonimo(w)) FROM UNNEST(SPLIT(LOWER(column_name), '_')) w WHERE w != '') as norm
  FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMNS\`
  WHERE table_name = '${v.tablaDestino}' AND column_name NOT IN (${pkListDestino.map(p => `'${p}'`).join(', ')}) AND data_type NOT IN ('ARRAY','STRUCT','RECORD')
),
-- Match exacto + por sin\u00f3nimos
matches AS (
  SELECT o.column_name as col_o, d.column_name as col_d
  FROM cols_origen o JOIN cols_destino d ON UPPER(o.column_name) = UPPER(d.column_name)
  UNION DISTINCT
  SELECT o.column_name, d.column_name
  FROM cols_origen o JOIN cols_destino d ON o.norm = d.norm
  WHERE NOT EXISTS (SELECT 1 FROM cols_destino d2 WHERE UPPER(o.column_name) = UPPER(d2.column_name))
)
SELECT
  STRING_AGG(
    CONCAT("CASE WHEN COALESCE(CAST(A.", col_o, " AS STRING), '') = COALESCE(CAST(B.", col_d, " AS STRING), '') THEN 0 ELSE 1 END AS diff_", col_o),
    ',\\n'
  ) AS bloque_diff,
  STRING_AGG(
    CONCAT("SUM(diff_", col_o, ") AS dif_", col_o),
    ',\\n'
  ) AS bloque_sum
FROM matches;`
                });

                queries.push({
                    code: 'UT-04-FINAL',
                    title: 'UT-04 Final: Resumen de Diferencias',
                    description: 'PASO 2: Pegar bloque_diff y bloque_sum donde indica',
                    isAuxiliary: false,
                    query: `-- UT-04 FINAL: Resumen de Diferencias - DIFERENTE ESTRUCTURA
-- PKs ORIGEN: ${pkListOrigen.join(', ')} | PKs DESTINO: ${pkListDestino.join(', ')}
-- Resultado esperado: dif_CAMPO = 0 para todos (sin diferencias)

WITH
  origen AS (
    SELECT * FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.${v.tablaOrigen}\` o
    ${v.joinOrigen ? v.joinOrigen + '\n    ' : ''}${filtroOrigenOneLine ? 'WHERE ' + filtroOrigenOneLine : ''}
  ),
  destino AS (
    SELECT * FROM \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\` d
    ${v.joinDestino ? v.joinDestino + '\n    ' : ''}${filtroDestinoOneLine ? 'WHERE ' + filtroDestinoOneLine : ''}
  ),
  joined AS (
    SELECT
      ${ut04PkSelect},
      -- \u2550\u2550\u2550 PEGAR AQU\u00cd 'bloque_diff' DEL UT-04-AUX \u2550\u2550\u2550
    FROM origen A
    FULL OUTER JOIN destino B
      ON ${ut04PkJoin}
  )
SELECT
  COUNT(1) AS total_registros,
  -- \u2550\u2550\u2550 PEGAR AQU\u00cd 'bloque_sum' DEL UT-04-AUX \u2550\u2550\u2550
FROM joined;`
                });
            }

            return queries;
        }

        function generateQAQueriesDifferent(v) {
            const pkListOrigen = v.pkListOrigen;
            const pkListDestino = v.pkListDestino;
            const camposListOrigen = v.camposListOrigen;
            const camposListDestino = v.camposListDestino;

            const whereOrigen = v.filtroOrigen ? `WHERE ${v.filtroOrigen}` : '';
            const whereDestino = v.filtroDestino ? `WHERE ${v.filtroDestino}` : '';
            const filtroOrigenOneLine = v.filtroOrigen ? v.filtroOrigen.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim() : '';
            const filtroDestinoOneLine = v.filtroDestino ? v.filtroDestino.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim() : '';

            // Filtro data_type para INFORMATION_SCHEMA (controlado por checkboxes "tiene bytes")
            // En claro: excluir BYTES (!=); Encriptado: incluir solo BYTES (=)
            const bytesOpQADiff = currentInfoType === 'encrypted' ? "= 'BYTES'" : "!= 'BYTES'";
            const bytesFilterOrigen = v.origenHasBytes ? `\n    AND data_type ${bytesOpQADiff}` : '';
            const bytesFilterDestino = v.destinoHasBytes ? `\n    AND data_type ${bytesOpQADiff}` : '';

            const queries = [];

            // R01: Existencia de tabla
            queries.push({
                code: 'R01',
                title: 'Existencia de Tabla',
                description: 'Valida que la tabla existe en el destino con fechas de creación/actualización',
                isAuxiliary: false,
                query: `-- R01: Existencia de Tabla con Metadatos
-- Resultado esperado: 1 registro con estado EXISTE

SELECT 
    project_id as proyecto,
    dataset_id as dataset,
    table_id as tabla,
    DATE(TIMESTAMP_MILLIS(creation_time)) as fecha_creacion,
    TIMESTAMP_MILLIS(last_modified_time) as fecha_actualizacion,
    row_count as cantidad_registros,
    ROUND(size_bytes / 1024 / 1024, 2) as tamano_mb,
    'EXISTE' as estado
FROM \`${v.proyectoDestino}.${v.datasetDestino}.__TABLES__\`
WHERE table_id = '${v.tablaDestino}';`
            });

            // R02: Cabeceras (con mapeo de PKs)
            queries.push({
                code: 'R02',
                title: 'Cabeceras / Estructura',
                description: 'Compara estructura de columnas entre origen y destino',
                isAuxiliary: false,
                query: `-- R02: Cabeceras / Estructura - DIFERENTE ESTRUCTURA
-- NOTA: PKs mapeados: ${pkListOrigen.join(', ')} → ${pkListDestino.join(', ')}
-- Resultado esperado: Solo diferencias esperadas por normalización

SELECT 
    'ORIGEN' as ambiente,
    column_name,
    data_type,
    CASE WHEN column_name IN (${pkListOrigen.map(p => `'${p}'`).join(', ')}) THEN 'PK' ELSE '' END as es_pk
FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.INFORMATION_SCHEMA.COLUMNS\`
WHERE table_name = '${v.tablaOrigen}'

UNION ALL

SELECT 
    'DESTINO' as ambiente,
    column_name,
    data_type,
    CASE WHEN column_name IN (${pkListDestino.map(p => `'${p}'`).join(', ')}) THEN 'PK' ELSE '' END as es_pk
FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMNS\`
WHERE table_name = '${v.tablaDestino}'

ORDER BY column_name, ambiente;`
            });

            // R03: Tipos de datos
            queries.push({
                code: 'R03',
                title: 'Tipos de Datos (Columnas Comunes)',
                description: 'Compara tipos de datos de columnas con nombres iguales',
                isAuxiliary: false,
                query: `-- R03: Tipos de Datos - Solo columnas con mismo nombre
-- Resultado esperado: 0 registros (todos los tipos coinciden)

SELECT 
    COALESCE(o.column_name, d.column_name) as columna,
    o.data_type as tipo_origen,
    d.data_type as tipo_destino,
    CASE WHEN o.data_type = d.data_type THEN 'OK' ELSE 'DIFERENTE' END as estado
FROM (
    SELECT column_name, data_type 
    FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.INFORMATION_SCHEMA.COLUMNS\` 
    WHERE table_name = '${v.tablaOrigen}'
) o
INNER JOIN (
    SELECT column_name, data_type 
    FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMNS\` 
    WHERE table_name = '${v.tablaDestino}'
) d ON UPPER(o.column_name) = UPPER(d.column_name)
WHERE o.data_type != d.data_type;`
            });

            // R04: Conteo de registros
            queries.push({
                code: 'R04',
                title: 'Conteo de Registros',
                description: 'Valida que el conteo sea igual entre ORIGEN y DESTINO',
                isAuxiliary: false,
                query: `-- R04: Conteo de Registros - DIFERENTE ESTRUCTURA
-- Resultado esperado: diferencia = 0, estado = PASS

WITH conteos AS (
    SELECT 
        (SELECT COUNT(*) FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.${v.tablaOrigen}\` ${whereOrigen}) as cnt_origen,
        (SELECT COUNT(*) FROM \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\` ${whereDestino}) as cnt_destino
)
SELECT 
    cnt_origen as registros_origen,
    cnt_destino as registros_destino,
    cnt_origen - cnt_destino as diferencia,
    CASE 
        WHEN cnt_origen = cnt_destino THEN 'PASS'
        ELSE 'FAIL'
    END as estado
FROM conteos;`
            });

            // R04-DIFF1: Registros SOLO en ORIGEN
            queries.push({
                code: 'R04-DIFF1',
                title: 'R04 Diferencias: Solo en ORIGEN',
                description: 'Muestra registros que existen en ORIGEN pero NO en DESTINO',
                isAuxiliary: true,
                query: `-- R04 DIFERENCIAS: Registros SOLO en ORIGEN
-- Muestra los registros que existen en ORIGEN pero NO en DESTINO
-- Usar cuando R04 muestra diferencias (estado = FAIL)

SELECT 
    'SOLO_ORIGEN' as ubicacion,
    ${pkListOrigen.map(pk => `o.${pk}`).join(', ')},
    o.*
FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.${v.tablaOrigen}\` o
LEFT JOIN \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\` d
    ON ${pkListOrigen.map((pk, i) => `CAST(o.${pk} AS STRING) = CAST(d.${pkListDestino[i]} AS STRING)`).join(' AND ')}
${filtroOrigenOneLine ? 'WHERE ' + filtroOrigenOneLine + ' AND ' : 'WHERE '}d.${pkListDestino[0]} IS NULL
ORDER BY ${pkListOrigen.map(pk => `o.${pk}`).join(', ')}
LIMIT 1000;`
            });

            // R04-DIFF2: Registros SOLO en DESTINO
            queries.push({
                code: 'R04-DIFF2',
                title: 'R04 Diferencias: Solo en DESTINO',
                description: 'Muestra registros que existen en DESTINO pero NO en ORIGEN',
                isAuxiliary: true,
                query: `-- R04 DIFERENCIAS: Registros SOLO en DESTINO
-- Muestra los registros que existen en DESTINO pero NO en ORIGEN
-- Usar cuando R04 muestra diferencias (estado = FAIL)

SELECT 
    'SOLO_DESTINO' as ubicacion,
    ${pkListDestino.map(pk => `d.${pk}`).join(', ')},
    d.*
FROM \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\` d
LEFT JOIN \`${v.proyectoOrigen}.${v.datasetOrigen}.${v.tablaOrigen}\` o
    ON ${pkListDestino.map((pk, i) => `CAST(d.${pk} AS STRING) = CAST(o.${pkListOrigen[i]} AS STRING)`).join(' AND ')}
${filtroDestinoOneLine ? 'WHERE ' + filtroDestinoOneLine + ' AND ' : 'WHERE '}o.${pkListOrigen[0]} IS NULL
ORDER BY ${pkListDestino.map(pk => `d.${pk}`).join(', ')}
LIMIT 1000;`
            });

            // R05: Campos no nulos
            const filtroR05 = v.filtroDestino ? ` WHERE ${v.filtroDestino.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim()}` : '';
            queries.push({
                code: 'R05',
                title: 'Campos No Nulos',
                description: 'Valida que los campos no tengan valores nulos (usa EXECUTE IMMEDIATE)',
                isAuxiliary: false,
                query: `-- R05: Campos No Nulos (en DESTINO) - EXECUTE IMMEDIATE
-- Resultado esperado: estado = PASS para cada campo (nulos = 0)

DECLARE query_nulos STRING;

SET query_nulos = (
    SELECT STRING_AGG(
        CONCAT(
            "SELECT '", column_name, "' as campo, COUNT(*) as total, ",
            "COUNTIF(", column_name, " IS NULL) as nulos, ",
            "ROUND(COUNTIF(", column_name, " IS NULL) * 100.0 / COUNT(*), 2) as pct_nulos, ",
            "CASE WHEN COUNTIF(", column_name, " IS NULL) = 0 THEN 'PASS' ELSE 'FAIL' END as estado ",
            "FROM \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\`${filtroR05}"
        ),
        ' UNION ALL '
    )
    FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMNS\`
    WHERE table_name = '${v.tablaDestino}'
      AND is_nullable = 'YES'${bytesFilterDestino}
      AND data_type NOT IN ('ARRAY', 'STRUCT', 'RECORD')
);

EXECUTE IMMEDIATE query_nulos;`
            });

            // R06: Sin duplicados - Auxiliar
            queries.push({
                code: 'R06-AUX',
                title: 'R06 Auxiliar: Obtener Columnas para Duplicados',
                description: 'PASO 1: Ejecutar primero para obtener las columnas del destino',
                isAuxiliary: true,
                query: `-- R06 AUXILIAR: Obtener columnas para validar duplicados
-- PASO 1: Ejecutar este query y copiar el resultado 'columnas_group'

SELECT 
    STRING_AGG(column_name, ', ') as columnas_group
FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMNS\`
WHERE table_name = '${v.tablaDestino}'
  AND data_type NOT IN ('ARRAY', 'STRUCT', 'RECORD', 'GEOGRAPHY', 'JSON')${bytesFilterDestino};`
            });

            // R06: Sin duplicados - Final
            queries.push({
                code: 'R06-FINAL',
                title: 'R06 Final: Sin Duplicados',
                description: 'PASO 2: Reemplazar <<COLUMNAS>> con el resultado del auxiliar',
                isAuxiliary: false,
                query: `-- R06 FINAL: Sin Duplicados - Todos los campos (en DESTINO)
-- PASO 2: Reemplazar <<COLUMNAS>> con 'columnas_group' del query auxiliar
-- Resultado esperado: 0 registros

SELECT 
    <<COLUMNAS>>,
    COUNT(*) as ocurrencias
FROM \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\` d
${v.joinDestino ? v.joinDestino + '\n' : ''}${whereDestino}
GROUP BY <<COLUMNAS>>
HAVING COUNT(*) > 1
ORDER BY ocurrencias DESC
LIMIT 100;`
            });

            // R07: Valores coinciden - con mapeo de PKs
            const pkJoinConditions = pkListOrigen.map((pkO, i) => 
                `CAST(A.${pkO} AS STRING) = CAST(B.${pkListDestino[i]} AS STRING)`
            ).join(' AND ');

            const pkSelectList = pkListOrigen.map((pkO, i) => 
                `COALESCE(CAST(A.${pkO} AS STRING), CAST(B.${pkListDestino[i]} AS STRING)) AS ${pkO}`
            ).join(',\n    ');

            if (camposListOrigen.length > 0 && camposListDestino.length > 0) {
                // Si hay campos mapeados manualmente
                const camposCompare = camposListOrigen.map((cO, i) => {
                    const cD = camposListDestino[i];
                    return `A.${cO} AS origen_${cO}, B.${cD} AS destino_${cD}, 
    CASE WHEN A.${cO} IS NULL AND B.${cD} IS NULL THEN 'IGUAL' 
         WHEN UPPER(TRIM(CAST(A.${cO} AS STRING))) = UPPER(TRIM(CAST(B.${cD} AS STRING))) THEN 'IGUAL' 
         ELSE 'DIFERENTE' END AS estado_${cO}`;
                }).join(',\n    ');

                queries.push({
                    code: 'R07',
                    title: 'Valores Coinciden (Mapeo Manual)',
                    description: 'Compara valores usando el mapeo de campos definido',
                    isAuxiliary: false,
                    query: `-- R07: Valores Coinciden - MAPEO MANUAL
-- PKs: ${pkListOrigen.join(', ')} → ${pkListDestino.join(', ')}
-- Campos: ${camposListOrigen.join(', ')} → ${camposListDestino.join(', ')}
-- Resultado esperado: 0 registros con diferencias
-- NOTA: Si desea obtener el total de diferencias, quitar el LIMIT 1000

WITH
  origen AS (
    SELECT * FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.${v.tablaOrigen}\` o
    ${v.joinOrigen ? v.joinOrigen + '\n    ' : ''}${filtroOrigenOneLine ? 'WHERE ' + filtroOrigenOneLine : ''}
  ),
  destino AS (
    SELECT * FROM \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\` d
    ${v.joinDestino ? v.joinDestino + '\n    ' : ''}${filtroDestinoOneLine ? 'WHERE ' + filtroDestinoOneLine : ''}
  )
SELECT DISTINCT
    ${pkSelectList},
    CASE 
        WHEN A.${pkListOrigen[0]} IS NULL THEN 'SOLO_DESTINO'
        WHEN B.${pkListDestino[0]} IS NULL THEN 'SOLO_ORIGEN'
        ELSE 'AMBOS'
    END as presencia,
    ${camposCompare}
FROM origen A
FULL OUTER JOIN destino B
    ON ${pkJoinConditions}
ORDER BY 1
LIMIT 1000;`
                });
            } else {
                // Sin campos mapeados, generar queries ejecutables
                // AUX1: Genera bloque para columnas con MISMO nombre (copiar directo)
                queries.push({
                    code: 'R07-AUX1',
                    title: 'R07 Auxiliar 1: Bloque para Columnas con Mismo Nombre',
                    description: 'PASO 1: Ejecutar y copiar resultado "bloque" (columnas con mismo nombre)',
                    isAuxiliary: true,
                    query: `-- R07 AUXILIAR 1: Generar bloque para columnas con MISMO nombre
-- PASO 1: Ejecutar este query y copiar el resultado 'bloque'
-- Este bloque cubre columnas que se llaman IGUAL en ambas tablas

WITH ORIGEN AS (
  SELECT column_name
  FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.INFORMATION_SCHEMA.COLUMNS\`
  WHERE table_name = '${v.tablaOrigen}'
    AND column_name NOT IN (${pkListOrigen.map(p => `'${p}'`).join(', ')})
    AND data_type NOT IN ('ARRAY', 'STRUCT', 'RECORD')
), 
DESTINO AS (
  SELECT column_name
  FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMNS\`
  WHERE table_name = '${v.tablaDestino}'
    AND column_name NOT IN (${pkListDestino.map(p => `'${p}'`).join(', ')})
    AND data_type NOT IN ('ARRAY', 'STRUCT', 'RECORD')
)
SELECT 
  STRING_AGG(
    CONCAT(
      'A.', a.column_name, ' AS origen_', a.column_name, ', ',
      'B.', b.column_name, ' AS destino_', b.column_name, ', ',
      "CASE WHEN A.", a.column_name, " IS NULL AND B.", b.column_name, " IS NULL THEN 'IGUAL' ",
      "WHEN UPPER(TRIM(CAST(A.", a.column_name, " AS STRING))) = UPPER(TRIM(CAST(B.", b.column_name, " AS STRING))) THEN 'IGUAL' ",
      "ELSE 'DIFERENTE' END AS estado_", a.column_name
    ),
    ',\\n'
  ) AS bloque 
FROM ORIGEN a  
JOIN DESTINO b ON UPPER(a.column_name) = UPPER(b.column_name);`
                });

                // AUX2: Lista columnas con diferente nombre y muestra matches por similitud + sinónimos
                queries.push({
                    code: 'R07-AUX2',
                    title: 'R07 Auxiliar 2: Matches por Similitud + Sinónimos',
                    description: 'PASO 2: Ver matches automáticos y columnas sin match',
                    isAuxiliary: true,
                    query: `-- R07 AUXILIAR 2: Matches por similitud + sinónimos y columnas sin match
-- PASO 2: Verificar matches automáticos y columnas pendientes de mapear
-- Sinónimos: nro=numero, cod=codigo, fec=fecha, desc=descripcion, etc.

-- Función para normalizar sinónimos
CREATE TEMP FUNCTION normalizar_sinonimo(palabra STRING) AS (
  CASE LOWER(palabra)
    WHEN 'nro' THEN 'numero' WHEN 'num' THEN 'numero' WHEN 'nr' THEN 'numero'
    WHEN 'cod' THEN 'codigo' WHEN 'cd' THEN 'codigo'
    WHEN 'id' THEN 'identificador' WHEN 'ident' THEN 'identificador'
    WHEN 'fec' THEN 'fecha' WHEN 'fch' THEN 'fecha' WHEN 'dt' THEN 'fecha' WHEN 'date' THEN 'fecha'
    WHEN 'desc' THEN 'descripcion' WHEN 'dsc' THEN 'descripcion'
    WHEN 'cant' THEN 'cantidad' WHEN 'qty' THEN 'cantidad'
    WHEN 'obs' THEN 'observacion'
    WHEN 'dir' THEN 'direccion'
    WHEN 'tel' THEN 'telefono' WHEN 'fon' THEN 'telefono'
    WHEN 'nom' THEN 'nombre' WHEN 'name' THEN 'nombre'
    WHEN 'tip' THEN 'tipo' WHEN 'type' THEN 'tipo'
    WHEN 'est' THEN 'estado' WHEN 'status' THEN 'estado'
    WHEN 'mto' THEN 'monto' WHEN 'mnt' THEN 'monto' WHEN 'amount' THEN 'monto'
    ELSE LOWER(palabra)
  END
);

WITH 
origen_sin_match AS (
  SELECT o.column_name,
    (SELECT STRING_AGG(normalizar_sinonimo(word), '_' ORDER BY normalizar_sinonimo(word)) 
     FROM UNNEST(SPLIT(LOWER(o.column_name), '_')) as word WHERE word != '') as palabras_norm
  FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.INFORMATION_SCHEMA.COLUMNS\` o
  WHERE o.table_name = '${v.tablaOrigen}'
    AND o.column_name NOT IN (${pkListOrigen.map(p => `'${p}'`).join(', ')})
    AND o.data_type NOT IN ('ARRAY', 'STRUCT', 'RECORD')
    AND NOT EXISTS (
      SELECT 1 FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMNS\` d
      WHERE d.table_name = '${v.tablaDestino}' AND UPPER(d.column_name) = UPPER(o.column_name)
    )
),
destino_sin_match AS (
  SELECT d.column_name,
    (SELECT STRING_AGG(normalizar_sinonimo(word), '_' ORDER BY normalizar_sinonimo(word)) 
     FROM UNNEST(SPLIT(LOWER(d.column_name), '_')) as word WHERE word != '') as palabras_norm
  FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMNS\` d
  WHERE d.table_name = '${v.tablaDestino}'
    AND d.column_name NOT IN (${pkListDestino.map(p => `'${p}'`).join(', ')})
    AND d.data_type NOT IN ('ARRAY', 'STRUCT', 'RECORD')
    AND NOT EXISTS (
      SELECT 1 FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.INFORMATION_SCHEMA.COLUMNS\` o
      WHERE o.table_name = '${v.tablaOrigen}' AND UPPER(o.column_name) = UPPER(d.column_name)
    )
)

-- Matches encontrados por similitud + sinónimos (se generarán en AUX3)
SELECT '✅ MATCH' as estado, o.column_name as col_origen, d.column_name as col_destino, 
       o.palabras_norm as match_por,
       'AUX3 generará el bloque' as accion
FROM origen_sin_match o
JOIN destino_sin_match d ON o.palabras_norm = d.palabras_norm

UNION ALL

-- Columnas de ORIGEN sin match (requieren mapeo manual)
SELECT '❌ SIN MATCH' as estado, o.column_name as col_origen, NULL as col_destino,
       o.palabras_norm as match_por,
       'Usar AUX4 (mapeo manual)' as accion
FROM origen_sin_match o
WHERE NOT EXISTS (
  SELECT 1 FROM destino_sin_match d WHERE o.palabras_norm = d.palabras_norm
)

UNION ALL

-- Columnas de DESTINO sin match (requieren mapeo manual)
SELECT '❌ SIN MATCH' as estado, NULL as col_origen, d.column_name as col_destino,
       d.palabras_norm as match_por,
       'Usar AUX4 (mapeo manual)' as accion
FROM destino_sin_match d
WHERE NOT EXISTS (
  SELECT 1 FROM origen_sin_match o WHERE o.palabras_norm = d.palabras_norm
)

ORDER BY estado DESC, col_origen, col_destino;`
                });

                // AUX3: Generar bloque automático para campos con diferente nombre (por similitud + sinónimos)
                queries.push({
                    code: 'R07-AUX3',
                    title: 'R07 Auxiliar 3: Bloque para Campos con Diferente Nombre',
                    description: 'PASO 3: Ejecutar y copiar resultado "bloque" (match por similitud + sinónimos)',
                    isAuxiliary: true,
                    query: `-- R07 AUXILIAR 3: Generar bloque para campos con DIFERENTE nombre
-- PASO 3: Ejecutar este query y copiar el resultado 'bloque'
-- Usa similitud de palabras + sinónimos: plan_nro ↔ NUMERO_PLAN, moneda_id ↔ id_moneda

-- Función para normalizar sinónimos
CREATE TEMP FUNCTION normalizar_sinonimo(palabra STRING) AS (
  CASE LOWER(palabra)
    -- Números
    WHEN 'nro' THEN 'numero'
    WHEN 'num' THEN 'numero'
    WHEN 'nr' THEN 'numero'
    -- Códigos
    WHEN 'cod' THEN 'codigo'
    WHEN 'cd' THEN 'codigo'
    -- Identificadores
    WHEN 'id' THEN 'identificador'
    WHEN 'ident' THEN 'identificador'
    -- Fechas
    WHEN 'fec' THEN 'fecha'
    WHEN 'fch' THEN 'fecha'
    WHEN 'dt' THEN 'fecha'
    WHEN 'date' THEN 'fecha'
    -- Descripciones
    WHEN 'desc' THEN 'descripcion'
    WHEN 'dsc' THEN 'descripcion'
    -- Cantidades
    WHEN 'cant' THEN 'cantidad'
    WHEN 'qty' THEN 'cantidad'
    -- Observaciones
    WHEN 'obs' THEN 'observacion'
    -- Direcciones
    WHEN 'dir' THEN 'direccion'
    -- Teléfonos
    WHEN 'tel' THEN 'telefono'
    WHEN 'fon' THEN 'telefono'
    -- Nombres
    WHEN 'nom' THEN 'nombre'
    WHEN 'name' THEN 'nombre'
    -- Tipos
    WHEN 'tip' THEN 'tipo'
    WHEN 'type' THEN 'tipo'
    -- Estados
    WHEN 'est' THEN 'estado'
    WHEN 'status' THEN 'estado'
    -- Montos
    WHEN 'mto' THEN 'monto'
    WHEN 'mnt' THEN 'monto'
    WHEN 'amount' THEN 'monto'
    ELSE LOWER(palabra)
  END
);

WITH 
-- Columnas de ORIGEN sin match exacto
origen_sin_match AS (
  SELECT o.column_name,
    -- Normalizar: aplicar sinónimos y ordenar palabras
    (SELECT STRING_AGG(normalizar_sinonimo(word), '_' ORDER BY normalizar_sinonimo(word)) 
     FROM UNNEST(SPLIT(LOWER(o.column_name), '_')) as word
     WHERE word != '') as palabras_norm
  FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.INFORMATION_SCHEMA.COLUMNS\` o
  WHERE o.table_name = '${v.tablaOrigen}'
    AND o.column_name NOT IN (${pkListOrigen.map(p => `'${p}'`).join(', ')})
    AND o.data_type NOT IN ('ARRAY', 'STRUCT', 'RECORD')
    AND NOT EXISTS (
      SELECT 1 FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMNS\` d
      WHERE d.table_name = '${v.tablaDestino}' AND UPPER(d.column_name) = UPPER(o.column_name)
    )
),
-- Columnas de DESTINO sin match exacto
destino_sin_match AS (
  SELECT d.column_name,
    -- Normalizar: aplicar sinónimos y ordenar palabras
    (SELECT STRING_AGG(normalizar_sinonimo(word), '_' ORDER BY normalizar_sinonimo(word)) 
     FROM UNNEST(SPLIT(LOWER(d.column_name), '_')) as word
     WHERE word != '') as palabras_norm
  FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMNS\` d
  WHERE d.table_name = '${v.tablaDestino}'
    AND d.column_name NOT IN (${pkListDestino.map(p => `'${p}'`).join(', ')})
    AND d.data_type NOT IN ('ARRAY', 'STRUCT', 'RECORD')
    AND NOT EXISTS (
      SELECT 1 FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.INFORMATION_SCHEMA.COLUMNS\` o
      WHERE o.table_name = '${v.tablaOrigen}' AND UPPER(o.column_name) = UPPER(d.column_name)
    )
),
-- Match por similitud de palabras (con sinónimos)
matches AS (
  SELECT 
    o.column_name as col_origen,
    d.column_name as col_destino
  FROM origen_sin_match o
  JOIN destino_sin_match d ON o.palabras_norm = d.palabras_norm
)
SELECT 
  CASE 
    WHEN COUNT(*) = 0 THEN '-- No se encontraron matches por similitud'
    ELSE STRING_AGG(
      CONCAT(
        'A.', col_origen, ' AS origen_', col_origen, ', ',
        'B.', col_destino, ' AS destino_', col_destino, ', ',
        "CASE WHEN A.", col_origen, " IS NULL AND B.", col_destino, " IS NULL THEN 'IGUAL' ",
        "WHEN UPPER(TRIM(CAST(A.", col_origen, " AS STRING))) = UPPER(TRIM(CAST(B.", col_destino, " AS STRING))) THEN 'IGUAL' ",
        "ELSE 'DIFERENTE' END AS estado_", col_origen
      ),
      ',\\n'
    )
  END AS bloque
FROM matches;`
                });

                // AUX4: Plantilla manual para campos sin match automático
                queries.push({
                    code: 'R07-AUX4',
                    title: 'R07 Auxiliar 4: Plantilla Manual (campos sin match)',
                    description: 'PASO 4: Solo si AUX2 muestra columnas ❌ SIN MATCH',
                    isAuxiliary: true,
                    query: `-- R07 AUXILIAR 4: Plantilla para campos que NO hicieron match automático
-- PASO 4: Solo usar si AUX2 muestra columnas con ❌ SIN MATCH
-- Copiar y reemplazar <<CAMPO_ORIGEN>> y <<CAMPO_DESTINO>> según corresponda

-- ═══════════════════════════════════════════════════════════════
-- PLANTILLA (copiar por cada par de campos sin match automático):
-- ═══════════════════════════════════════════════════════════════

A.<<CAMPO_ORIGEN>> AS origen_<<CAMPO_ORIGEN>>, 
B.<<CAMPO_DESTINO>> AS destino_<<CAMPO_DESTINO>>, 
CASE 
    WHEN A.<<CAMPO_ORIGEN>> IS NULL AND B.<<CAMPO_DESTINO>> IS NULL THEN 'IGUAL' 
    WHEN UPPER(TRIM(CAST(A.<<CAMPO_ORIGEN>> AS STRING))) = UPPER(TRIM(CAST(B.<<CAMPO_DESTINO>> AS STRING))) THEN 'IGUAL' 
    ELSE 'DIFERENTE' 
END AS estado_<<CAMPO_ORIGEN>>,

-- ═══════════════════════════════════════════════════════════════
-- EJEMPLO: Si nombre_completo (origen) → full_name (destino)
-- ═══════════════════════════════════════════════════════════════

A.nombre_completo AS origen_nombre_completo, 
B.full_name AS destino_full_name, 
CASE 
    WHEN A.nombre_completo IS NULL AND B.full_name IS NULL THEN 'IGUAL' 
    WHEN UPPER(TRIM(CAST(A.nombre_completo AS STRING))) = UPPER(TRIM(CAST(B.full_name AS STRING))) THEN 'IGUAL' 
    ELSE 'DIFERENTE' 
END AS estado_nombre_completo,`
                });

                queries.push({
                    code: 'R07-FINAL',
                    title: 'R07 Final: Valores Coinciden',
                    description: 'PASO 5: Pegar bloques de AUX1 + AUX3 + AUX4 (si aplica)',
                    isAuxiliary: false,
                    query: `-- R07 FINAL: Valores Coinciden - DIFERENTE ESTRUCTURA
-- PKs ORIGEN: ${pkListOrigen.join(', ')}
-- PKs DESTINO: ${pkListDestino.join(', ')}
-- 
-- INSTRUCCIONES:
--   1. Pegar el 'bloque' del AUX1 (columnas con MISMO nombre)
--   2. Pegar el 'bloque' del AUX3 (columnas con DIFERENTE nombre - match automático)
--   3. Si AUX2 mostró columnas ❌ SIN MATCH, agregar del AUX4 (mapeo manual)
--
-- Resultado esperado: 0 registros con diferencias
-- NOTA: Si desea obtener el total de diferencias, quitar el LIMIT 1000

WITH
  origen AS (
    SELECT * FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.${v.tablaOrigen}\` o
    ${v.joinOrigen ? v.joinOrigen + '\n    ' : ''}${filtroOrigenOneLine ? 'WHERE ' + filtroOrigenOneLine : ''}
  ),
  destino AS (
    SELECT * FROM \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\` d
    ${v.joinDestino ? v.joinDestino + '\n    ' : ''}${filtroDestinoOneLine ? 'WHERE ' + filtroDestinoOneLine : ''}
  )
SELECT DISTINCT
    ${pkSelectList},
    CASE 
        WHEN A.${pkListOrigen[0]} IS NULL THEN 'SOLO_DESTINO'
        WHEN B.${pkListDestino[0]} IS NULL THEN 'SOLO_ORIGEN'
        ELSE 'AMBOS'
    END as presencia,
    -- ═══════════════════════════════════════════════════════════════
    -- [AUX1] PEGAR AQUÍ: Columnas con MISMO nombre
    -- ═══════════════════════════════════════════════════════════════
    
    -- ═══════════════════════════════════════════════════════════════
    -- [AUX3] PEGAR AQUÍ: Columnas con DIFERENTE nombre (match automático)
    -- ═══════════════════════════════════════════════════════════════
    
    -- ═══════════════════════════════════════════════════════════════
    -- [AUX4] PEGAR AQUÍ: Columnas sin match automático (mapeo manual)
    -- (Solo si AUX2 mostró columnas con ❌ SIN MATCH)
    -- ═══════════════════════════════════════════════════════════════
FROM origen A
FULL OUTER JOIN destino B
    ON ${pkJoinConditions}
ORDER BY 1
LIMIT 1000;`
                });
            }


            // R08: Resumen de Diferencias campo a campo (Diferente Estructura)
            const ut04PkJoin = pkListOrigen.map((pkO, i) => 
                `CAST(A.${pkO} AS STRING) = CAST(B.${pkListDestino[i]} AS STRING)`
            ).join(' AND ');
            const ut04PkSelect = pkListOrigen.map((pkO, i) => 
                `COALESCE(CAST(A.${pkO} AS STRING), CAST(B.${pkListDestino[i]} AS STRING)) AS ${pkO}`
            ).join(',\n      ');

            if (camposListOrigen.length > 0 && camposListDestino.length > 0) {
                // Con mapeo manual
                const diffBlocks = camposListOrigen.map((cO, i) => {
                    const cD = camposListDestino[i];
                    return `CASE WHEN COALESCE(CAST(A.${cO} AS STRING), '') = COALESCE(CAST(B.${cD} AS STRING), '') THEN 0 ELSE 1 END AS diff_${cO}`;
                }).join(',\n      ');

                const sumBlocks = camposListOrigen.map(cO => 
                    `SUM(diff_${cO}) AS dif_${cO}`
                ).join(',\n  ');

                queries.push({
                    code: 'R08',
                    title: 'Resumen de Diferencias (Mapeo Manual)',
                    description: 'Resumen campo a campo de diferencias entre origen y destino',
                    isAuxiliary: false,
                    query: `-- R08: Resumen de Diferencias campo a campo - MAPEO MANUAL
-- PKs: ${pkListOrigen.join(', ')} \u2192 ${pkListDestino.join(', ')}
-- Resultado esperado: dif_CAMPO = 0 para todos (sin diferencias)

WITH
  origen AS (
    SELECT * FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.${v.tablaOrigen}\` o
    ${v.joinOrigen ? v.joinOrigen + '\n    ' : ''}${filtroOrigenOneLine ? 'WHERE ' + filtroOrigenOneLine : ''}
  ),
  destino AS (
    SELECT * FROM \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\` d
    ${v.joinDestino ? v.joinDestino + '\n    ' : ''}${filtroDestinoOneLine ? 'WHERE ' + filtroDestinoOneLine : ''}
  ),
  joined AS (
    SELECT
      ${ut04PkSelect},
      ${diffBlocks}
    FROM origen A
    FULL OUTER JOIN destino B
      ON ${ut04PkJoin}
  )
SELECT
  COUNT(1) AS total_registros,
  ${sumBlocks}
FROM joined;`
                });
            } else {
                // Sin mapeo manual - usar AUX
                queries.push({
                    code: 'R08-AUX',
                    title: 'R08 Auxiliar: Generar Bloques de Comparaci\u00f3n',
                    description: 'PASO 1: Ejecutar y copiar bloque_diff y bloque_sum',
                    isAuxiliary: true,
                    query: `-- R08 AUXILIAR: Generar bloques para Resumen de Diferencias (Diferente Estructura)
-- PASO 1: Ejecutar y copiar 'bloque_diff' y 'bloque_sum'
-- Incluye: columnas con mismo nombre + matches por sin\u00f3nimos

CREATE TEMP FUNCTION normalizar_sinonimo(palabra STRING) AS (
  CASE LOWER(palabra)
    WHEN 'nro' THEN 'numero' WHEN 'num' THEN 'numero' WHEN 'nr' THEN 'numero'
    WHEN 'cod' THEN 'codigo' WHEN 'cd' THEN 'codigo'
    WHEN 'id' THEN 'identificador' WHEN 'ident' THEN 'identificador'
    WHEN 'fec' THEN 'fecha' WHEN 'fch' THEN 'fecha' WHEN 'dt' THEN 'fecha'
    WHEN 'desc' THEN 'descripcion' WHEN 'dsc' THEN 'descripcion'
    WHEN 'nom' THEN 'nombre' WHEN 'name' THEN 'nombre'
    WHEN 'tip' THEN 'tipo' WHEN 'type' THEN 'tipo'
    WHEN 'est' THEN 'estado' WHEN 'status' THEN 'estado'
    WHEN 'mto' THEN 'monto' WHEN 'mnt' THEN 'monto' WHEN 'amount' THEN 'monto'
    ELSE LOWER(palabra)
  END
);

WITH 
cols_origen AS (
  SELECT column_name,
    (SELECT STRING_AGG(normalizar_sinonimo(w), '_' ORDER BY normalizar_sinonimo(w)) FROM UNNEST(SPLIT(LOWER(column_name), '_')) w WHERE w != '') as norm
  FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.INFORMATION_SCHEMA.COLUMNS\`
  WHERE table_name = '${v.tablaOrigen}' AND column_name NOT IN (${pkListOrigen.map(p => `'${p}'`).join(', ')}) AND data_type NOT IN ('ARRAY','STRUCT','RECORD')
),
cols_destino AS (
  SELECT column_name,
    (SELECT STRING_AGG(normalizar_sinonimo(w), '_' ORDER BY normalizar_sinonimo(w)) FROM UNNEST(SPLIT(LOWER(column_name), '_')) w WHERE w != '') as norm
  FROM \`${v.proyectoDestino}.${v.datasetDestino}.INFORMATION_SCHEMA.COLUMNS\`
  WHERE table_name = '${v.tablaDestino}' AND column_name NOT IN (${pkListDestino.map(p => `'${p}'`).join(', ')}) AND data_type NOT IN ('ARRAY','STRUCT','RECORD')
),
-- Match exacto + por sin\u00f3nimos
matches AS (
  SELECT o.column_name as col_o, d.column_name as col_d
  FROM cols_origen o JOIN cols_destino d ON UPPER(o.column_name) = UPPER(d.column_name)
  UNION DISTINCT
  SELECT o.column_name, d.column_name
  FROM cols_origen o JOIN cols_destino d ON o.norm = d.norm
  WHERE NOT EXISTS (SELECT 1 FROM cols_destino d2 WHERE UPPER(o.column_name) = UPPER(d2.column_name))
)
SELECT
  STRING_AGG(
    CONCAT("CASE WHEN COALESCE(CAST(A.", col_o, " AS STRING), '') = COALESCE(CAST(B.", col_d, " AS STRING), '') THEN 0 ELSE 1 END AS diff_", col_o),
    ',\\n'
  ) AS bloque_diff,
  STRING_AGG(
    CONCAT("SUM(diff_", col_o, ") AS dif_", col_o),
    ',\\n'
  ) AS bloque_sum
FROM matches;`
                });

                queries.push({
                    code: 'R08-FINAL',
                    title: 'R08 Final: Resumen de Diferencias',
                    description: 'PASO 2: Pegar bloque_diff y bloque_sum donde indica',
                    isAuxiliary: false,
                    query: `-- R08 FINAL: Resumen de Diferencias - DIFERENTE ESTRUCTURA
-- PKs ORIGEN: ${pkListOrigen.join(', ')} | PKs DESTINO: ${pkListDestino.join(', ')}
-- Resultado esperado: dif_CAMPO = 0 para todos (sin diferencias)

WITH
  origen AS (
    SELECT * FROM \`${v.proyectoOrigen}.${v.datasetOrigen}.${v.tablaOrigen}\` o
    ${v.joinOrigen ? v.joinOrigen + '\n    ' : ''}${filtroOrigenOneLine ? 'WHERE ' + filtroOrigenOneLine : ''}
  ),
  destino AS (
    SELECT * FROM \`${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}\` d
    ${v.joinDestino ? v.joinDestino + '\n    ' : ''}${filtroDestinoOneLine ? 'WHERE ' + filtroDestinoOneLine : ''}
  ),
  joined AS (
    SELECT
      ${ut04PkSelect},
      -- \u2550\u2550\u2550 PEGAR AQU\u00cd 'bloque_diff' DEL R08-AUX \u2550\u2550\u2550
    FROM origen A
    FULL OUTER JOIN destino B
      ON ${ut04PkJoin}
  )
SELECT
  COUNT(1) AS total_registros,
  -- \u2550\u2550\u2550 PEGAR AQU\u00cd 'bloque_sum' DEL R08-AUX \u2550\u2550\u2550
FROM joined;`
                });
            }

            return queries;
        }


        // ═══════════════════════════════════════════════════════════════
        // generateEncryptedQueries: Tabla Encriptada (BYTES)
        // - Tabla RECORD: campos BYTES dentro de una columna RECORD (usa UNNEST)
        // - Tabla Simple / Diferente Estructura: campos BYTES top-level (sin UNNEST)
        // El WHERE se toma del filtroOrigen/filtroDestino estándar.
        // Los checkboxes origenHasBytes/destinoHasBytes controlan AND data_type='BYTES'
        // FIX: usa DECLARE vars para tabla/where y patron "FROM \`", var, "\` t\n"
        //      para evitar backtick-quoted identifiers dentro de strings "..." en BigQuery
        // ═══════════════════════════════════════════════════════════════
        function generateEncryptedQueries(v) {
            const isRecord = currentTableType === 'record';

            // Para RECORD: usar las columnas RECORD estándar (recordColumnOrigen / recordColumnDestino)
            const recColOrigen = isRecord ? (v.recordColumnOrigen || 'RECORD_COL_ORIGEN') : null;
            const recColDestino = isRecord ? (v.recordColumnDestino || 'RECORD_COL_DESTINO') : null;

            // WHERE desde los filtros estándar
            const whereOrigenInput = v.filtroOrigen ? v.filtroOrigen.trim() : '';
            const whereDestinoInput = v.filtroDestino ? v.filtroDestino.trim() : '';
            const whereOrigen = whereOrigenInput ? (whereOrigenInput.toUpperCase().startsWith('WHERE') ? whereOrigenInput : 'WHERE ' + whereOrigenInput) : '';
            const whereDestino = whereDestinoInput ? (whereDestinoInput.toUpperCase().startsWith('WHERE') ? whereDestinoInput : 'WHERE ' + whereDestinoInput) : '';

            const tablaOrigen = v.proyectoOrigen + '.' + v.datasetOrigen + '.' + v.tablaOrigen;
            const tablaDestino = v.proyectoDestino + '.' + v.datasetDestino + '.' + v.tablaDestino;

            // Filtro data_type segun checkboxes
            const bytesFilterOrigen = v.origenHasBytes ? "\n    AND data_type = 'BYTES'" : '';
            const bytesFilterDestino = v.destinoHasBytes ? "\n    AND data_type = 'BYTES'" : '';

            // Prefijo segun modo: UT -> UT-E, QA -> RE
            const rP = currentMode === 'ut' ? 'UT-E' : 'RE';

            const queries = [];

            // Helpers: bloque INFORMATION_SCHEMA y acceso a campos segun tipo
            const ischemaSrcRecord = (proyecto, dataset, tabla, recCol, bytesFilter) =>
                `\`${proyecto}.${dataset}.INFORMATION_SCHEMA.COLUMN_FIELD_PATHS\`\n  WHERE table_name = '${tabla}'\n    AND column_name = '${recCol}'\n    AND field_path != '${recCol}'${bytesFilter}`;
            const ischemaSrcSimple = (proyecto, dataset, tabla, bytesFilter) =>
                `\`${proyecto}.${dataset}.INFORMATION_SCHEMA.COLUMNS\`\n  WHERE table_name = '${tabla}'${bytesFilter}`;

            const campoSelectRecord = (recCol) => `REPLACE(field_path, CONCAT('${recCol}', '.'), '') AS campo`;
            const campoSelectSimple = `column_name AS campo`;

            const ischemaDestinoBlock = isRecord
                ? ischemaSrcRecord(v.proyectoDestino, v.datasetDestino, v.tablaDestino, recColDestino, bytesFilterDestino)
                : ischemaSrcSimple(v.proyectoDestino, v.datasetDestino, v.tablaDestino, bytesFilterDestino);

            const campoSelectBlock = isRecord ? campoSelectRecord(recColDestino) : campoSelectSimple;

            // DECLARE blocks
            // Tabla names y WHERE como variables BigQuery para evitar backticks en "..."
            // Normalizar saltos de linea en WHERE (BigQuery no acepta "..." multilinea)
            const whOrigenSafe = whereOrigen.replace(/\s*\n\s*/g, ' ').trim();
            const whDestinoSafe = whereDestino.replace(/\s*\n\s*/g, ' ').trim();
            const declareBase = 'DECLARE tabla_origen STRING DEFAULT \'' + tablaOrigen + '\';\n'
                + 'DECLARE tabla_destino STRING DEFAULT \'' + tablaDestino + '\';\n'
                + 'DECLARE wh_origen STRING DEFAULT "' + whOrigenSafe + '";\n'
                + 'DECLARE wh_destino STRING DEFAULT "' + whDestinoSafe + '";';

            const declareBlock = isRecord
                ? ('DECLARE record_col_origen STRING DEFAULT \'' + recColOrigen + '\';\n'
                   + 'DECLARE record_col_destino STRING DEFAULT \'' + recColDestino + '\';\n'
                   + declareBase)
                : declareBase;

            // FROM patterns en CONCAT usando vars DECLARE + backtick escapado en borde de string
            // Simple:  "FROM \`", tabla_origen, "\` t\n",
            // Record:  "FROM \`", tabla_origen, "\` t, UNNEST(t.", record_col_origen, ") r\n",
            const fromOrigenConcat = isRecord
                ? '"FROM \\`", tabla_origen, "\\` t, UNNEST(t.", record_col_origen, ") r\\n",'
                : '"FROM \\`", tabla_origen, "\\` t\\n",';
            const fromDestinoConcat = isRecord
                ? '"FROM \\`", tabla_destino, "\\` t, UNNEST(t.", record_col_destino, ") r\\n",'
                : '"FROM \\`", tabla_destino, "\\` t\\n",';

            // Accessor de campo
            const accessOrigen = isRecord ? 'r' : 't';
            const accessDestino = isRecord ? 'r' : 't';

            // Nota del tipo
            const tipoNota = isRecord
                ? `-- Tipo tabla: RECORD -> campos BYTES dentro de columna RECORD '${recColOrigen}' (origen) / '${recColDestino}' (destino) con UNNEST`
                : `-- Tipo tabla: Simple/Diferente -> campos BYTES top-level, acceso directo sin UNNEST`;

            // ─────────────────────────────────────────────────────────────
            // REGLA 1: Conteo de Registros
            // ─────────────────────────────────────────────────────────────
            queries.push({
                code: rP + '01',
                title: rP + '01: Conteo de Registros',
                description: 'Valida que la cantidad de registros sea igual entre ORIGEN y DESTINO',
                isAuxiliary: false,
                query: `-- ` + rP + `01: Conteo de Registros (ORIGEN vs DESTINO)
-- ===========================================================================
-- DEFINICION: Compara el total de registros entre origen (texto claro) y
--   destino (tabla encriptada). La encriptacion no debe alterar el conteo.
-- INSTRUCCIONES:
--   Resultado esperado: diferencia = 0, estado = PASS
-- ===========================================================================

WITH conteos AS (
    SELECT
        (SELECT COUNT(*) FROM \`${tablaOrigen}\` o ${v.joinOrigen ? v.joinOrigen + ' ' : ''}${whereOrigen}) AS cnt_origen,
        (SELECT COUNT(*) FROM \`${tablaDestino}\` d ${v.joinDestino ? v.joinDestino + ' ' : ''}${whereDestino}) AS cnt_destino
)
SELECT
    cnt_origen  AS registros_origen,
    cnt_destino AS registros_destino,
    cnt_origen - cnt_destino AS diferencia,
    CASE
        WHEN cnt_origen = cnt_destino THEN 'PASS'
        ELSE 'FAIL'
    END AS estado
FROM conteos;`
            });

            // ─────────────────────────────────────────────────────────────
            // REGLA 2: Top 5 Valores Mas Frecuentes
            // ─────────────────────────────────────────────────────────────
            queries.push({
                code: rP + '02-META',
                title: rP + '02: Top 5 Valores Mas Frecuentes - Meta-Query (PASO 1)',
                description: 'Genera el SQL de comparacion. Ejecutar -> copiar sql_generado -> ejecutar el resultado.',
                isAuxiliary: true,
                query: `-- ` + rP + `02: Top 5 Valores Mas Frecuentes por Campo Encriptado
-- ===========================================================================
-- DEFINICION: Compara los 5 valores mas frecuentes por campo BYTES (destino
--   encriptado) vs STRING (origen texto). Detecta si la distribucion de datos
--   se preserva despues del proceso de encriptacion.
-- ` + tipoNota + `
-- INSTRUCCIONES:
--   1. Ejecutar este meta-query en BigQuery (requiere modo scripting / multi-sentencia)
--   2. Copiar el resultado completo de la columna sql_generado
--   3. Ejecutar el SQL copiado en BigQuery para obtener la comparacion real
--   4. Resultado esperado: los valores HEX de DESTINO deben corresponder
--      a la encriptacion de los valores STRING de ORIGEN
-- ===========================================================================

` + declareBlock + `

-- PASO 1: Obtiene campos BYTES de destino y genera SQL de comparacion
WITH campos AS (
  SELECT ` + campoSelectBlock + `
  FROM ` + ischemaDestinoBlock + `
)
SELECT CONCAT(
  STRING_AGG(
    CONCAT(
      "-- Top 5 frecuentes: ", campo, "\\n",
      "SELECT '", campo, "' AS campo, 'ORIGEN (STRING)' AS fuente, ",
      "CAST(` + accessOrigen + `.", campo, " AS STRING) AS valor, ",
      "COUNT(*) AS frecuencia, ",
      "RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking\\n",
      ` + fromOrigenConcat + `
      wh_origen, "\\n",
      "GROUP BY valor\\n",
      "QUALIFY ranking <= 5\\n",
      "UNION ALL\\n",
      "SELECT '", campo, "' AS campo, 'DESTINO (HEX/BYTES)' AS fuente, ",
      "TO_HEX(` + accessDestino + `.", campo, ") AS valor, ",
      "COUNT(*) AS frecuencia, ",
      "RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking\\n",
      ` + fromDestinoConcat + `
      wh_destino, "\\n",
      "GROUP BY valor\\n",
      "QUALIFY ranking <= 5"
    ),
    "\\nUNION ALL\\n"
  ),
  "\\nORDER BY campo, fuente, ranking"
) AS sql_generado
FROM campos;`
            });

            // ─────────────────────────────────────────────────────────────
            // REGLA 3: Valores Nulos y Vacios
            // ─────────────────────────────────────────────────────────────
            queries.push({
                code: rP + '03-META',
                title: rP + '03: Valores Nulos/Vacios - Meta-Query (PASO 1)',
                description: 'Genera SQL para comparar nulos y vacios en campos encriptados. Ejecutar -> copiar sql_generado -> ejecutar.',
                isAuxiliary: true,
                query: `-- ` + rP + `03: Valores Nulos y Vacios en Campos Encriptados
-- ===========================================================================
-- DEFINICION: Compara la cantidad de nulos y vacios por campo STRING (origen)
--   vs campo BYTES (destino encriptado). Un nulo en origen debe producir un
--   nulo o bytes vacios en destino (b""). Detecta perdida de datos.
-- ` + tipoNota + `
-- INSTRUCCIONES:
--   1. Ejecutar este meta-query en BigQuery (modo scripting)
--   2. Copiar el resultado de la columna sql_generado
--   3. Ejecutar el SQL copiado para ver el detalle de nulos/vacios por campo
--   4. Resultado esperado: nulos ORIGEN = nulos DESTINO para cada campo
-- ===========================================================================

` + declareBlock + `

WITH campos AS (
  SELECT ` + campoSelectBlock + `
  FROM ` + ischemaDestinoBlock + `
)
SELECT CONCAT(
  STRING_AGG(
    CONCAT(
      "-- Nulos/Vacios para campo: ", campo, "\\n",
      "SELECT '", campo, "' AS campo, 'ORIGEN (STRING)' AS fuente, ",
      "COUNT(*) AS total, ",
      "COUNTIF(` + accessOrigen + `.", campo, " IS NULL) AS nulos, ",
      "COUNTIF(` + accessOrigen + `.", campo, " = '') AS vacios\\n",
      ` + fromOrigenConcat + `
      wh_origen, "\\n",
      "UNION ALL\\n",
      "SELECT '", campo, "' AS campo, 'DESTINO (BYTES)' AS fuente, ",
      "COUNT(*) AS total, ",
      "COUNTIF(` + accessDestino + `.", campo, " IS NULL) AS nulos, ",
      "COUNTIF(` + accessDestino + `.", campo, " = b'') AS vacios\\n",
      ` + fromDestinoConcat + `
      wh_destino, "\\n"
    ),
    "\\nUNION ALL\\n"
  ),
  "\\nORDER BY campo, fuente"
) AS sql_generado
FROM campos;`
            });

            // ─────────────────────────────────────────────────────────────
            // REGLA 4: Top 5 Longitud de Campos
            // ─────────────────────────────────────────────────────────────
            queries.push({
                code: rP + '04-META',
                title: rP + '04: Top 5 Longitud de Campos - Meta-Query (PASO 1)',
                description: 'Genera SQL para comparar longitudes de campos encriptados. Ejecutar -> copiar sql_generado -> ejecutar.',
                isAuxiliary: true,
                query: `-- ` + rP + `04: Top 5 Longitudes de Campos Encriptados
-- ===========================================================================
-- DEFINICION: Compara las 5 longitudes en bytes mas frecuentes por campo
--   STRING (origen) vs BYTES (destino encriptado). Un algoritmo de encriptacion
--   deterministico debe producir una longitud constante para cada valor original,
--   lo que permite verificar la consistencia del proceso.
-- ` + tipoNota + `
-- INSTRUCCIONES:
--   1. Ejecutar este meta-query en BigQuery (modo scripting)
--   2. Copiar el resultado de la columna sql_generado
--   3. Ejecutar el SQL copiado para ver longitudes por campo
--   4. Resultado esperado: longitudes de DESTINO deben ser uniformes
--      (encriptacion deterministica produce bytes de longitud fija)
-- ===========================================================================

` + declareBlock + `

WITH campos AS (
  SELECT ` + campoSelectBlock + `
  FROM ` + ischemaDestinoBlock + `
)
SELECT CONCAT(
  STRING_AGG(
    CONCAT(
      "-- Longitudes para campo: ", campo, "\\n",
      "SELECT '", campo, "' AS campo, 'ORIGEN (STRING)' AS fuente, ",
      "OCTET_LENGTH(` + accessOrigen + `.", campo, ") AS longitud, ",
      "COUNT(*) AS frecuencia, ",
      "RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking\\n",
      ` + fromOrigenConcat + `
      wh_origen, "\\n",
      "GROUP BY longitud\\n",
      "QUALIFY ranking <= 5\\n",
      "UNION ALL\\n",
      "SELECT '", campo, "' AS campo, 'DESTINO (BYTES)' AS fuente, ",
      "OCTET_LENGTH(` + accessDestino + `.", campo, ") AS longitud, ",
      "COUNT(*) AS frecuencia, ",
      "RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking\\n",
      ` + fromDestinoConcat + `
      wh_destino, "\\n",
      "GROUP BY longitud\\n",
      "QUALIFY ranking <= 5"
    ),
    "\\nUNION ALL\\n"
  ),
  "\\nORDER BY campo, fuente, ranking"
) AS sql_generado
FROM campos;`
            });

            return queries;
        }

        function generateQueries() {
            if (!validateForm()) {
                return;
            }

            const v = getInputValues();
            let queries;
            
            if (currentInfoType === 'encrypted') {
                queries = generateEncryptedQueries(v);
            } else if (currentTableType === 'different') {
                queries = currentMode === 'ut' ? generateUTQueriesDifferent(v) : generateQAQueriesDifferent(v);
            } else {
                queries = currentMode === 'ut' ? generateUTQueries(v) : generateQAQueries(v);
            }

            const grid = document.getElementById('queriesGrid');
            grid.innerHTML = '';

            queries.forEach((q, index) => {
                const card = document.createElement('div');
                card.className = 'query-card' + (q.isAuxiliary ? ' auxiliary' : '');
                
                const stepIndicator = q.code.includes('AUX') ? '<span class="step-indicator">PASO 1</span>' : 
                                     q.code.includes('FINAL') ? '<span class="step-indicator">PASO 2</span>' : '';
                
                card.innerHTML = `
                    <div class="query-header">
                        <h4>${q.title}${stepIndicator}</h4>
                        <span class="code-badge">${q.code}</span>
                    </div>
                    <div class="query-body">
                        <button class="btn-copy" onclick="copyQuery(this, ${index})">📋 Copiar</button>
                        <pre id="query-${index}">${escapeHtml(q.query)}</pre>
                    </div>
                `;
                grid.appendChild(card);
            });

            window.generatedQueries = queries;
            window.inputValues = v;

            document.getElementById('queriesSection').scrollIntoView({ behavior: 'smooth' });
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function copyQuery(btn, index) {
            const query = window.generatedQueries[index].query;
            navigator.clipboard.writeText(query).then(() => {
                btn.textContent = '✓ Copiado';
                btn.classList.add('copied');
                setTimeout(() => {
                    btn.textContent = '📋 Copiar';
                    btn.classList.remove('copied');
                }, 2000);
            });
        }

        function exportPipelineToExcel() {
            // Verificar que hay queries generados
            if (!generatedPipelineQueries || generatedPipelineQueries.length === 0) {
                alert('Primero genera los queries con el botón "Generar Queries de Validación Pipeline"');
                return;
            }
            
            // Verificar que hay datos del pipeline
            if (pipelineAnalysis.rawTables.length === 0 || pipelineAnalysis.masterTables.length === 0) {
                alert('No se detectaron suficientes tablas. Asegúrate de que el SP tenga tablas RAW y MASTER/BUSINESS.');
                return;
            }

            // Usar los queries ya generados
            const queries = generatedPipelineQueries.map(q => ({
                ...q,
                expectedResult: q.expectedResult || getExpectedResult(q.code)
            }));
            
            function getExpectedResult(code) {
                if (code === 'PL-01') return 'diferencia = 0 para todos los pasos';
                if (code === 'PL-02') return 'no_en_master = 0 para todas las tablas';
                if (code === 'PL-03') return '0 duplicados, 0 nulos en PKs, 0 huérfanos';
                return '';
            }
            
            const masterTable = pipelineAnalysis.masterTables[0];
            const masterTableName = masterTable.split('.').pop();
            const pksInput = document.getElementById('masterPKs').value.trim();
            const pksDisplay = pksInput || pipelineAnalysis.detectedPKs.join(', ') || 'auto-detectadas';
            
            // ═══════════════════════════════════════════════════════════════
            // GENERAR EXCEL
            // ═══════════════════════════════════════════════════════════════
            const now = new Date();
            const wb = XLSX.utils.book_new();

            // Sheet 1: Instrucciones
            const instructionsData = [
                ['INSTRUCCIONES DE USO - ANÁLISIS DE PIPELINE'],
                [''],
                ['Este archivo contiene los queries de validación de pipeline generados.'],
                [''],
                ['REGLAS INCLUIDAS:'],
                ['- PL-01: Resumen del pipeline con conteos por paso'],
                ['- PL-02: Registros perdidos (tablas intermedias vs MASTER/BUSINESS)'],
                ['- PL-03: Calidad de datos en MASTER/BUSINESS (duplicados, nulos, huérfanos)'],
                [''],
                ['PASOS A SEGUIR:'],
                ['1. Revisar la hoja "Inputs" para verificar la configuración'],
                ['2. Ejecutar cada query en BigQuery'],
                ['3. Registrar los resultados en la hoja "Resultados"'],
                [''],
                ['CRITERIOS DE ÉXITO:'],
                ['- PL-01: diferencia = 0 para todos los pasos'],
                ['- PL-02: no_en_master = 0 para todas las tablas'],
                ['- PL-03: 0 duplicados, 0 nulos en PKs, 0 huérfanos'],
                [''],
                ['Generado el: ' + now.toLocaleString()],
                ['Modo: Análisis de Pipeline']
            ];
            const wsInstructions = XLSX.utils.aoa_to_sheet(instructionsData);
            wsInstructions['!cols'] = [{ wch: 80 }];
            XLSX.utils.book_append_sheet(wb, wsInstructions, 'Instrucciones');

            // Sheet 2: Inputs - Formato tabular como en UT/QA
            const inputsData = [
                ['CONFIGURACIÓN DEL PIPELINE'],
                [''],
                ['Modo:', 'Análisis de Pipeline (SP)'],
                ['Tabla MASTER/BUSINESS:', masterTable],
                ['PKs:', pksDisplay],
                ['Fecha Generación:', now.toLocaleString()],
                [''],
                ['DETALLE DE TABLAS DETECTADAS'],
                ['Tipo', 'Tabla Completa', 'Tabla Nombre'],
                ...pipelineAnalysis.rawTables.map(t => ['RAW', t, t.split('.').pop()]),
                ...pipelineAnalysis.tempTables.map(t => ['TEMP', t, t.split('.').pop()]),
                ...pipelineAnalysis.masterTables.map(t => ['MASTER/BUSINESS', t, t.split('.').pop()]),
                [''],
                ['PKs DETECTADAS'],
                ...pipelineAnalysis.detectedPKs.map((pk, i) => [`PK ${i+1}:`, pk])
            ];
            
            const wsInputs = XLSX.utils.aoa_to_sheet(inputsData);
            wsInputs['!cols'] = [{ wch: 20 }, { wch: 60 }, { wch: 30 }];
            XLSX.utils.book_append_sheet(wb, wsInputs, 'Inputs');

            // Sheet 3: Resultados - Misma estructura que UT/QA
            const resultsData = [
                ['RESULTADOS DE VALIDACIÓN DE PIPELINE'],
                [''],
                ['Tabla MASTER/BUSINESS:', masterTable],
                ['PKs:', pksDisplay],
                ['Fecha Ejecución General:', ''],
                ['Ejecutado por:', ''],
                [''],
                ['RESUMEN'],
                ['Total Reglas:', queries.length],
                ['Reglas PASS:', ''],
                ['Reglas FAIL:', ''],
                ['% Cumplimiento:', ''],
                [''],
                ['DETALLE DE REGLAS'],
                ['Código', 'Regla', 'Tipo', 'Query Auxiliar', 'Query Final', 'Resultado Esperado', 'Resultado Obtenido', 'Estado', 'Fecha Ejecución Regla', 'Observación']
            ];
            
            queries.forEach(q => {
                resultsData.push([
                    q.code, 
                    q.title, 
                    'Directo',  // Tipo
                    'N/A',      // Query Auxiliar
                    q.query,    // Query Final
                    q.expectedResult, 
                    '', 
                    '', 
                    '', 
                    ''
                ]);
            });
            
            const wsResults = XLSX.utils.aoa_to_sheet(resultsData);
            wsResults['!cols'] = [
                { wch: 10 },  // Código
                { wch: 30 },  // Regla
                { wch: 10 },  // Tipo
                { wch: 20 },  // Query Auxiliar
                { wch: 100 }, // Query Final
                { wch: 40 },  // Resultado Esperado
                { wch: 25 },  // Resultado Obtenido
                { wch: 10 },  // Estado
                { wch: 22 },  // Fecha Ejecución Regla
                { wch: 40 }   // Observación
            ];
            XLSX.utils.book_append_sheet(wb, wsResults, 'Resultados');

            const fileName = `Validacion_Pipeline_${masterTableName}_${now.toISOString().slice(0,10)}.xlsx`;
            XLSX.writeFile(wb, fileName);
        }
        
        function exportToExcel() {
            // Si estamos en modo pipeline, exportar queries de pipeline
            if (currentMode === 'pipeline') {
                exportPipelineToExcel();
                return;
            }
            
            if (!window.generatedQueries || !window.inputValues) {
                alert('Primero genera los queries');
                return;
            }

            const v = window.inputValues;
            const queries = window.generatedQueries;
            const now = new Date();

            // Determinar texto del tipo de tabla e información
            let tipoTablaTexto = 'Tabla Simple';
            if (currentInfoType === 'encrypted') tipoTablaTexto = 'Tabla Encriptada (BYTES)';
            else if (currentTableType === 'record') tipoTablaTexto = 'Tabla con RECORD';
            else if (currentTableType === 'different') tipoTablaTexto = 'Tabla con Diferente Estructura';
            const tipoInfoTexto = currentInfoType === 'encrypted' ? 'Encriptado (BYTES)' : 'En claro';

            const wb = XLSX.utils.book_new();

            // Sheet 1: Instrucciones
            const instructionsData = [
                ['INSTRUCCIONES DE USO'],
                [''],
                ['Este archivo contiene los queries de validación generados.'],
                ['Los campos se obtienen automáticamente de INFORMATION_SCHEMA.'],
                [''],
                ['PASOS A SEGUIR:'],
                ['1. Revisar la hoja "Inputs" para verificar la configuración'],
                ['2. Para cada regla con 2 pasos:'],
                ['   a. Ejecutar primero el query AUXILIAR (PASO 1)'],
                ['   b. Copiar el resultado del auxiliar'],
                ['   c. Reemplazar los <<PLACEHOLDER>> en el query FINAL (PASO 2)'],
                ['3. Ejecutar cada query en BigQuery'],
                ['4. Registrar los resultados en la hoja "Resultados"'],
                [''],
                ['PLACEHOLDERS A REEMPLAZAR:'],
                ['- <<COLUMNAS>>: Lista de columnas separadas por coma'],
                ['- <<BLOQUE>>: Bloque de comparación generado por query auxiliar'],
                [''],
                ...(currentInfoType === 'encrypted' ? [
                    ['PASOS PARA REGLAS ENCRIPTADAS (E01-E04 / RE01-RE04):'],
                    ['- E01/RE01: Ejecutar directamente. Resultado esperado: diferencia = 0, estado = PASS.'],
                    ['- E02/RE02 (Top 5 Valores):'],
                    ['  1. Ejecutar el Meta-Query (columna "Query Auxiliar") → obtiene campo sql_generado'],
                    ['  2. Copiar el contenido de sql_generado'],
                    ['  3. Pegar y ejecutar en BigQuery → compara STRING (origen) vs HEX (destino)'],
                    ['- E03/RE03 (Nulos/Vacíos): mismos 3 pasos que E02'],
                    ['- E04/RE04 (Longitud): mismos 3 pasos que E02'],
                ] : [
                    ['CRITERIOS DE ÉXITO:'],
                    ['- UT-01/R04: diferencia = 0, estado = PASS'],
                    ['- UT-02/R06: 0 registros duplicados'],
                    ['- UT-03/R07: 0 registros con diferencias'],
                    ['- UT-04/R08: 0 registros con diferencias'],
                    ['- R01: Tabla existe con fechas'],
                    ['- R02: 0 columnas faltantes'],
                    ['- R03: 0 tipos diferentes'],
                    ['- R05: estado = PASS (0 nulos)'],
                ]),
                [''],
                ['Generado el: ' + now.toLocaleString()],
                ['Modo: ' + (currentMode === 'ut' ? 'Pruebas Unitarias' : 'Validación QA')],
                ['Tipo tabla: ' + tipoTablaTexto],
                ['Tipo información: ' + tipoInfoTexto]
            ];
            const wsInstructions = XLSX.utils.aoa_to_sheet(instructionsData);
            wsInstructions['!cols'] = [{ wch: 80 }];
            XLSX.utils.book_append_sheet(wb, wsInstructions, 'Instrucciones');

            // Sheet 2: Inputs - Formato Tabular
            const inputsData = [
                ['CONFIGURACIÓN DE VALIDACIÓN'],
                [''],
                ['Modo:', currentMode === 'ut' ? 'Pruebas Unitarias' : 'Validación QA'],
                ['Tipo de Tabla:', tipoTablaTexto],
                ['Tipo de Información:', tipoInfoTexto],
                currentInfoType !== 'encrypted' && currentTableType === 'different' ? ['PKs Origen:', v.pkOrigen] : (currentInfoType !== 'encrypted' ? ['Primary Keys:', v.primaryKeys] : []),
                currentInfoType !== 'encrypted' && currentTableType === 'different' ? ['PKs Destino:', v.pkDestino] : [],
                ['Fecha Generación:', now.toLocaleString()],
                currentInfoType !== 'encrypted' && currentTableType === 'record' ? ['Columna RECORD:', `Origen: ${v.recordColumnOrigen} | Destino: ${v.recordColumnDestino}`] : [],
                currentInfoType !== 'encrypted' && currentTableType === 'different' && v.camposOrigen ? ['Campos Origen:', v.camposOrigen] : [],
                currentInfoType !== 'encrypted' && currentTableType === 'different' && v.camposDestino ? ['Campos Destino:', v.camposDestino] : [],
                currentInfoType === 'encrypted' && currentTableType === 'record' ? ['RECORD Col Origen (Encriptado):', v.recordColumnOrigen] : [],
                currentInfoType === 'encrypted' && currentTableType === 'record' ? ['RECORD Col Destino (Encriptado):', v.recordColumnDestino] : [],
                (currentInfoType === 'encrypted' || currentTableType === 'record') ? ['Origen - Tiene campos BYTES:', v.origenHasBytes ? (currentInfoType === 'encrypted' ? "Sí (AND data_type = 'BYTES')" : "Sí (AND data_type != 'BYTES')") : 'No'] : [],
                (currentInfoType === 'encrypted' || currentTableType === 'record') ? ['Destino - Tiene campos BYTES:', v.destinoHasBytes ? (currentInfoType === 'encrypted' ? "Sí (AND data_type = 'BYTES')" : "Sí (AND data_type != 'BYTES')") : 'No'] : [],
                [''],
                ['DETALLE DE CONEXIONES'],
                ['Ambiente', 'Proyecto', 'Dataset', 'Tabla', 'Filtro WHERE', 'JOIN Adicional'],
                ['ORIGEN', v.proyectoOrigen, v.datasetOrigen, v.tablaOrigen, v.filtroOrigen || '', v.joinOrigen || ''],
                ['DESTINO', v.proyectoDestino, v.datasetDestino, v.tablaDestino, v.filtroDestino || '', v.joinDestino || '']
            ].filter(row => row.length > 0);
            
            const wsInputs = XLSX.utils.aoa_to_sheet(inputsData);
            wsInputs['!cols'] = [
                { wch: 15 }, { wch: 30 }, { wch: 20 }, { wch: 25 }, { wch: 50 }, { wch: 50 }
            ];
            XLSX.utils.book_append_sheet(wb, wsInputs, 'Inputs');

            // Para encriptado: exportar E01 (directo) + META queries (E02, E03, E04)
            // Para otros modos: exportar solo queries NO auxiliares (FINAL y directos)
            const isEncrypted = currentInfoType === 'encrypted';
            const queriesToExport = isEncrypted
                ? queries.filter(q => !q.isAuxiliary || q.code.includes('-META'))
                : queries.filter(q => !q.isAuxiliary);

            // Sheet 3: Resultados y Queries combinados
            const resultsData = [
                ['RESULTADOS DE VALIDACIÓN'],
                [''],
                ['Tabla Origen:', `${v.proyectoOrigen}.${v.datasetOrigen}.${v.tablaOrigen}`],
                ['Tabla Destino:', `${v.proyectoDestino}.${v.datasetDestino}.${v.tablaDestino}`],
                ['Fecha Ejecución General:', ''],
                ['Ejecutado por:', ''],
                [''],
                ['RESUMEN'],
                ['Total Reglas:', queriesToExport.length],
                ['Reglas PASS:', ''],
                ['Reglas FAIL:', ''],
                ['% Cumplimiento:', ''],
                [''],
                ['DETALLE DE REGLAS'],
                ['Código', 'Regla', 'Tipo', 'Query Auxiliar (o Meta-Query)', 'Query Final', 'Resultado Esperado', 'Resultado Obtenido', 'Estado', 'Fecha Ejecución Regla', 'Observación']
            ];
            
            queriesToExport.forEach(q => {
                let expectedResult = '';
                const isMeta = q.code.includes('-META');
                const baseCode = q.code.replace('-FINAL', '').replace('-META', '');

                // Mapeo de resultados esperados
                if (baseCode === 'UT-01' || baseCode === 'R04') expectedResult = 'diferencia = 0, estado = PASS';
                else if (baseCode === 'UT-02' || baseCode === 'R06') expectedResult = '0 duplicados';
                else if (baseCode === 'UT-03' || baseCode === 'R07') expectedResult = '0 diferencias (LIMIT 1000)';
                else if (baseCode === 'UT-04' || baseCode === 'R08') expectedResult = '0 registros con diferencias';
                else if (baseCode === 'R01') expectedResult = 'Tabla existe + fechas';
                else if (baseCode === 'R02') expectedResult = '0 columnas faltantes';
                else if (baseCode === 'R03') expectedResult = '0 tipos diferentes';
                else if (baseCode === 'R05' || q.code === 'R05') expectedResult = 'estado = PASS (0 nulos)';
                // Encriptadas: E01 = conteo, E02 = top5, E03 = nulos, E04 = longitud
                else if (/E01$/.test(baseCode)) expectedResult = 'diferencia = 0, estado = PASS';
                else if (/E02$/.test(baseCode)) expectedResult = 'Distribución de valores comparable (STRING vs HEX)';
                else if (/E03$/.test(baseCode)) expectedResult = 'nulos ORIGEN = nulos DESTINO por campo';
                else if (/E04$/.test(baseCode)) expectedResult = 'Longitudes BYTES consistentes (encriptación determinística)';

                let queryAux = 'N/A (directo)';
                let queryFinal = q.query;
                let tipo = 'Directo';

                if (isMeta) {
                    // Meta-query: la query ES el PASO 1; el "final" es la instrucción del PASO 2
                    queryAux = q.query;
                    queryFinal = '(PASO 2) Copiar el resultado del campo "sql_generado" y ejecutarlo directamente en BigQuery como una nueva consulta.';
                    tipo = 'Meta-Query (2 pasos)';
                } else {
                    // Buscar queries auxiliares relacionados (AUX, AUX1, AUX2, AUX3, AUX4)
                    const auxQueries = queries.filter(aux => 
                        aux.isAuxiliary && 
                        (aux.code === baseCode + '-AUX' || 
                         aux.code === baseCode + '-AUX1' || 
                         aux.code === baseCode + '-AUX2' ||
                         aux.code === baseCode + '-AUX3' ||
                         aux.code === baseCode + '-AUX4')
                    );

                    if (auxQueries.length === 1) {
                        queryAux = auxQueries[0].query;
                    } else if (auxQueries.length > 1) {
                        queryAux = auxQueries.map(aq => `-- ${aq.code} --\n${aq.query}`).join('\n\n');
                    }

                    if (q.code.includes('FINAL')) {
                        if (auxQueries.length >= 4) tipo = '5 pasos';
                        else if (auxQueries.length === 3) tipo = '4 pasos';
                        else if (auxQueries.length === 2) tipo = '3 pasos';
                        else if (auxQueries.length === 1) tipo = '2 pasos';
                    }
                }
                
                resultsData.push([
                    q.code, 
                    q.title, 
                    tipo, 
                    queryAux,
                    queryFinal,
                    expectedResult, 
                    '', 
                    '', 
                    '', 
                    ''
                ]);
            });
            
            const wsResults = XLSX.utils.aoa_to_sheet(resultsData);
            wsResults['!cols'] = [
                { wch: 12 },  // Código
                { wch: 30 },  // Regla
                { wch: 10 },  // Tipo
                { wch: 80 },  // Query Auxiliar
                { wch: 80 },  // Query Final
                { wch: 30 },  // Resultado Esperado
                { wch: 25 },  // Resultado Obtenido
                { wch: 10 },  // Estado
                { wch: 22 },  // Fecha Ejecución Regla
                { wch: 40 }   // Observación
            ];
            XLSX.utils.book_append_sheet(wb, wsResults, 'Resultados');

            const fileName = `Validacion_${v.tablaDestino}_${currentMode.toUpperCase()}_${now.toISOString().slice(0,10)}.xlsx`;
            XLSX.writeFile(wb, fileName);
        }
    </script>
</body>
</html>
